# videoconference4k - Source Code

Project structure with 20 files:

## capture/
- __init__.py
- audio.py
- video.py

## conference/
- __init__.py
- multipeer.py
- peer.py

## net/
- __init__.py
- async_.py
- sync.py

## root/
- __init__.py
- pyproject.toml
- version.py

## rtc/
- __init__.py
- connection.py
- tracks.py

## stream/
- __init__.py
- video.py

## utils/
- __init__.py
- common.py
- nvidia_codec.py

---

## File: __init__.py

```python
"""
VideoConference4k
=================

A lightweight peer-to-peer video conferencing library for 4K60 streaming.

Author: Blair Chintella (vici0549@gmail.com)
License: Apache-2.0
"""

from .version import __version__
from .capture import VideoCapture, AudioCapture
from .stream import VideoStream
from .net import SyncTransport, AsyncTransport
from .rtc import RTCConnection
from .conference import PeerConference, MultiPeerConference

__author__ = "Blair Chintella <vici0549@gmail.com>"

__all__ = [
    "VideoCapture",
    "AudioCapture",
    "VideoStream",
    "SyncTransport",
    "AsyncTransport",
    "RTCConnection",
    "PeerConference",
    "MultiPeerConference",
    "__version__",
]
```

---

## File: capture/__init__.py

```python
from .video import VideoCapture
from .audio import AudioCapture

__all__ = ["VideoCapture", "AudioCapture"]
```

---

## File: capture/audio.py

```python
import numpy as np
import logging as log
import threading
import queue
from typing import TypeVar, Optional, Callable, Union
from numpy.typing import NDArray

from ..utils.common import (
    logger_handler,
    import_dependency_safe,
    log_version,
)

sd = import_dependency_safe("sounddevice", error="silent")

logger = log.getLogger("AudioCapture")
logger.propagate = False
logger.addHandler(logger_handler())
logger.setLevel(log.DEBUG)

T = TypeVar("T", bound="AudioCapture")


class AudioCapture:

    def __init__(
        self,
        input_device: Optional[Union[int, str]] = None,
        output_device: Optional[Union[int, str]] = None,
        sample_rate: int = 48000,
        channels: int = 1,
        chunk_size: int = 960,
        dtype: str = "int16",
        enable_input: bool = True,
        enable_output: bool = True,
        logging: bool = False,
        **options: dict
    ):
        self.__logging = logging if isinstance(logging, bool) else False

        log_version(logging=self.__logging)

        import_dependency_safe("sounddevice" if sd is None else "")

        self.__sample_rate = sample_rate
        self.__channels = channels
        self.__chunk_size = chunk_size
        self.__dtype = dtype
        self.__enable_input = enable_input
        self.__enable_output = enable_output

        self.__input_device = input_device
        self.__output_device = output_device

        self.__input_queue = queue.Queue(maxsize=100)
        self.__output_queue = queue.Queue(maxsize=100)

        self.__input_stream = None
        self.__output_stream = None

        self.__terminate = threading.Event()
        self.__is_running = False

        self.__on_audio_callback = None

        options = {str(k).strip(): v for k, v in options.items()}

        if "latency" in options:
            self.__latency = options["latency"]
        else:
            self.__latency = "low"

        if "blocksize" in options:
            self.__chunk_size = options["blocksize"]

        self.__logging and logger.debug(
            "AudioCapture initialized with sample_rate={}, channels={}, chunk_size={}, dtype={}".format(
                self.__sample_rate, self.__channels, self.__chunk_size, self.__dtype
            )
        )

    @property
    def sample_rate(self) -> int:
        return self.__sample_rate

    @property
    def channels(self) -> int:
        return self.__channels

    @property
    def chunk_size(self) -> int:
        return self.__chunk_size

    @property
    def dtype(self) -> str:
        return self.__dtype

    @property
    def is_running(self) -> bool:
        return self.__is_running

    @staticmethod
    def get_devices() -> dict:
        import_dependency_safe("sounddevice" if sd is None else "")
        devices = sd.query_devices()
        input_devices = []
        output_devices = []
        for i, dev in enumerate(devices):
            if dev["max_input_channels"] > 0:
                input_devices.append({"index": i, "name": dev["name"], "channels": dev["max_input_channels"]})
            if dev["max_output_channels"] > 0:
                output_devices.append({"index": i, "name": dev["name"], "channels": dev["max_output_channels"]})
        return {"input": input_devices, "output": output_devices}

    def set_audio_callback(self, callback: Callable[[NDArray], None]) -> None:
        if callable(callback):
            self.__on_audio_callback = callback
            self.__logging and logger.debug("Audio callback registered.")
        else:
            logger.warning("Invalid callback provided. Must be callable.")

    def __input_callback(self, indata, frames, time_info, status):
        if status:
            self.__logging and logger.warning("Input status: {}".format(status))
        if not self.__terminate.is_set():
            audio_data = indata.copy()
            try:
                self.__input_queue.put_nowait(audio_data)
            except queue.Full:
                pass
            if self.__on_audio_callback is not None:
                try:
                    self.__on_audio_callback(audio_data)
                except Exception as e:
                    logger.error("Error in audio callback: {}".format(e))

    def __output_callback(self, outdata, frames, time_info, status):
        if status:
            self.__logging and logger.warning("Output status: {}".format(status))
        try:
            data = self.__output_queue.get_nowait()
            if data.ndim == 1:
                data = data.reshape(-1, 1)
            samples_to_copy = min(data.shape[0], outdata.shape[0])
            outdata[:samples_to_copy] = data[:samples_to_copy]
            if samples_to_copy < outdata.shape[0]:
                outdata[samples_to_copy:] = 0
        except queue.Empty:
            outdata.fill(0)

    def start(self) -> T:
        if self.__is_running:
            self.__logging and logger.warning("AudioCapture is already running.")
            return self

        self.__terminate.clear()

        if self.__enable_input:
            try:
                self.__input_stream = sd.InputStream(
                    device=self.__input_device,
                    samplerate=self.__sample_rate,
                    channels=self.__channels,
                    dtype=self.__dtype,
                    blocksize=self.__chunk_size,
                    latency=self.__latency,
                    callback=self.__input_callback,
                )
                self.__input_stream.start()
                self.__logging and logger.debug("Input stream started.")
            except Exception as e:
                logger.error("Failed to start input stream: {}".format(e))
                raise

        if self.__enable_output:
            try:
                self.__output_stream = sd.OutputStream(
                    device=self.__output_device,
                    samplerate=self.__sample_rate,
                    channels=self.__channels,
                    dtype=self.__dtype,
                    blocksize=self.__chunk_size,
                    latency=self.__latency,
                    callback=self.__output_callback,
                )
                self.__output_stream.start()
                self.__logging and logger.debug("Output stream started.")
            except Exception as e:
                logger.error("Failed to start output stream: {}".format(e))
                raise

        self.__is_running = True
        self.__logging and logger.debug("AudioCapture started successfully.")
        return self

    def read(self, timeout: Optional[float] = None) -> Optional[NDArray]:
        if not self.__enable_input:
            logger.warning("Input is not enabled.")
            return None
        try:
            return self.__input_queue.get(timeout=timeout)
        except queue.Empty:
            return None

    def write(self, audio_data: NDArray) -> bool:
        if not self.__enable_output:
            logger.warning("Output is not enabled.")
            return False
        if not isinstance(audio_data, np.ndarray):
            logger.warning("Invalid audio data type. Expected numpy array.")
            return False
        try:
            self.__output_queue.put_nowait(audio_data)
            return True
        except queue.Full:
            return False

    def clear_output_queue(self) -> None:
        while not self.__output_queue.empty():
            try:
                self.__output_queue.get_nowait()
            except queue.Empty:
                break

    def clear_input_queue(self) -> None:
        while not self.__input_queue.empty():
            try:
                self.__input_queue.get_nowait()
            except queue.Empty:
                break

    def stop(self) -> None:
        self.__logging and logger.debug("Stopping AudioCapture.")
        self.__terminate.set()
        self.__is_running = False

        if self.__input_stream is not None:
            try:
                self.__input_stream.stop()
                self.__input_stream.close()
                self.__logging and logger.debug("Input stream stopped.")
            except Exception as e:
                logger.error("Error stopping input stream: {}".format(e))
            self.__input_stream = None

        if self.__output_stream is not None:
            try:
                self.__output_stream.stop()
                self.__output_stream.close()
                self.__logging and logger.debug("Output stream stopped.")
            except Exception as e:
                logger.error("Error stopping output stream: {}".format(e))
            self.__output_stream = None

        self.clear_input_queue()
        self.clear_output_queue()

        self.__logging and logger.debug("AudioCapture stopped successfully.")
```

---

## File: capture/video.py

```python
import cv2
import time
import queue
import logging as log
from threading import Thread, Event, Lock
from typing import TypeVar, Optional, Any
from numpy.typing import NDArray

from ..utils.common import (
    capPropId,
    logger_handler,
    check_CV_version,
    import_dependency_safe,
    log_version,
)

logger = log.getLogger("VideoCapture")
logger.propagate = False
logger.addHandler(logger_handler())
logger.setLevel(log.DEBUG)

T = TypeVar("T", bound="VideoCapture")


class VideoCapture:

    def __init__(
        self,
        source: Any = 0,
        backend: int = 0,
        colorspace: str = None,
        logging: bool = False,
        time_delay: int = 0,
        **options: dict
    ):
        self.__logging = logging if isinstance(logging, bool) else False

        log_version(logging=self.__logging)

        self.__threaded_queue_mode = options.pop("THREADED_QUEUE_MODE", True)
        if not isinstance(self.__threaded_queue_mode, bool):
            self.__threaded_queue_mode = True
        self.__thread_timeout = options.pop("THREAD_TIMEOUT", None)
        if self.__thread_timeout and isinstance(self.__thread_timeout, (int, float)):
            self.__thread_timeout = float(self.__thread_timeout)
        else:
            self.__thread_timeout = None

        self.__default_queue_timeout = 1.0

        self.__queue = None
        if self.__threaded_queue_mode and isinstance(source, str):
            self.__queue = queue.Queue(maxsize=96)
            self.__logging and logger.debug(
                "Enabling Threaded Queue Mode for the current video source!"
            )
        else:
            self.__threaded_queue_mode = False
            self.__logging and logger.warning(
                "Threaded Queue Mode is disabled for the current video source!"
            )

        self.__thread_timeout and logger.info(
            "Setting Video-Thread Timeout to {}s.".format(self.__thread_timeout)
        )

        self.stream = None

        if backend and isinstance(backend, int):
            if check_CV_version() == 3:
                self.stream = cv2.VideoCapture(source + backend)
            else:
                self.stream = cv2.VideoCapture(source, backend)
            logger.info("Setting backend `{}` for this source.".format(backend))
        else:
            self.stream = cv2.VideoCapture(source)

        self.color_space = None

        options = {str(k).strip(): v for k, v in options.items()}
        for key, value in options.items():
            property = capPropId(key)
            not (property is None) and self.stream.set(property, value)

        if not (colorspace is None):
            self.color_space = capPropId(colorspace.strip())
            self.__logging and not (self.color_space is None) and logger.debug(
                "Enabling `{}` colorspace for this video stream!".format(
                    colorspace.strip()
                )
            )

        self.framerate = 0.0
        _fps = self.stream.get(cv2.CAP_PROP_FPS)
        if _fps > 1.0:
            self.framerate = _fps

        time_delay and isinstance(time_delay, (int, float)) and time.sleep(time_delay)

        (grabbed, self.frame) = self.stream.read()

        if grabbed:
            if not (self.color_space is None):
                self.frame = cv2.cvtColor(self.frame, self.color_space)

            self.__threaded_queue_mode and self.__queue.put(self.frame)
        else:
            raise RuntimeError(
                "[VideoCapture:ERROR] :: Source is invalid, VideoCapture failed to initialize stream on this source!"
            )

        self.__thread = None

        self.__terminate = Event()

        self.__stream_read = Event()

        self.__frame_lock = Lock()

        self.__is_running = False

    @property
    def is_running(self) -> bool:
        return self.__is_running

    def start(self) -> T:
        if self.__is_running and self.__thread is not None and self.__thread.is_alive():
            self.__logging and logger.warning("VideoCapture is already running.")
            return self
        self.__terminate.clear()
        self.__is_running = True
        self.__thread = Thread(target=self.__update, name="VideoCapture", args=())
        self.__thread.daemon = True
        self.__thread.start()
        return self

    def __update(self):
        while not self.__terminate.is_set():
            self.__stream_read.clear()

            (grabbed, frame) = self.stream.read()

            if not grabbed:
                if self.__threaded_queue_mode:
                    if self.__queue.empty():
                        break
                    else:
                        continue
                else:
                    break

            if not (self.color_space is None):
                color_frame = None
                try:
                    color_frame = cv2.cvtColor(frame, self.color_space)
                except Exception as e:
                    color_frame = None
                    self.color_space = None
                    self.__logging and logger.exception(str(e))
                    logger.warning("Assigned colorspace value is invalid. Discarding!")
                frame = color_frame if not (color_frame is None) else frame

            if self.__threaded_queue_mode:
                self.__queue.put(frame)
            else:
                with self.__frame_lock:
                    self.frame = frame

            self.__stream_read.set()

        self.__threaded_queue_mode and self.__queue.put(None)
        self.__threaded_queue_mode = False

        self.__terminate.set()
        self.__stream_read.set()
        self.__is_running = False

        self.stream.release()

    def read(self) -> Optional[NDArray]:
        if not self.__is_running:
            self.__logging and logger.warning(
                "VideoCapture is not running. Returning initial frame. Call start() for continuous capture."
            )
            with self.__frame_lock:
                return self.frame

        while self.__threaded_queue_mode and not self.__terminate.is_set():
            try:
                timeout = self.__thread_timeout if self.__thread_timeout else self.__default_queue_timeout
                frame = self.__queue.get(timeout=timeout)
                return frame
            except queue.Empty:
                if self.__terminate.is_set():
                    return None
                continue
        if not self.__terminate.is_set() and self.__stream_read.wait(timeout=self.__thread_timeout):
            with self.__frame_lock:
                return self.frame
        return None

    def stop(self) -> None:
        self.__logging and logger.debug("Terminating processes.")
        self.__threaded_queue_mode = False
        self.__is_running = False

        self.__stream_read.set()
        self.__terminate.set()

        if self.__thread is not None:
            if not (self.__queue is None):
                while not self.__queue.empty():
                    try:
                        self.__queue.get_nowait()
                    except queue.Empty:
                        continue
                    self.__queue.task_done()
            self.__thread.join()
            self.__thread = None
```

---

## File: conference/__init__.py

```python
from .peer import PeerConference
from .multipeer import MultiPeerConference

__all__ = ["PeerConference", "MultiPeerConference"]
```

---

## File: conference/multipeer.py

```python
import json
import base64
import zlib
import threading
import time
import logging as log
from typing import Optional, Callable, Tuple, Dict
import numpy as np
from numpy.typing import NDArray

from ..stream.video import VideoStream
from ..capture.audio import AudioCapture
from ..rtc.connection import RTCConnection
from ..utils.common import logger_handler, log_version

logger = log.getLogger("MultiPeerConference")
logger.propagate = False
logger.addHandler(logger_handler())
logger.setLevel(log.DEBUG)

STUN_ONLY_SERVERS = [
    {"urls": ["stun:stun.l.google.com:19302"]},
    {"urls": ["stun:stun1.l.google.com:19302"]},
    {"urls": ["stun:stun.stunprotocol.org:3478"]},
]


def _compress_sdp(sdp_dict: dict) -> str:
    json_bytes = json.dumps(sdp_dict, separators=(',', ':')).encode('utf-8')
    compressed = zlib.compress(json_bytes, level=9)
    return base64.urlsafe_b64encode(compressed).decode('ascii')


def _decompress_sdp(code: str) -> dict:
    try:
        compressed = base64.urlsafe_b64decode(code.encode('ascii'))
        json_bytes = zlib.decompress(compressed)
        return json.loads(json_bytes.decode('utf-8'))
    except Exception as e:
        raise ValueError(
            "Invalid code. Make sure you copied the entire code correctly."
        ) from e


class MultiPeerConference:

    def __init__(
        self,
        resolution: Tuple[int, int] = (1920, 1080),
        framerate: int = 30,
        enable_audio: bool = True,
        camera_id: int = 0,
        microphone_id: Optional[int] = None,
        max_peers: int = 3,
        logging: bool = False,
        **options: dict
    ):
        self.__logging = logging if isinstance(logging, bool) else False

        log_version(logging=self.__logging)

        self.__resolution = resolution
        self.__framerate = framerate
        self.__enable_audio = enable_audio
        self.__max_peers = max_peers

        options = {str(k).strip(): v for k, v in options.items()}

        self.__video = VideoStream(
            source=camera_id,
            resolution=resolution,
            framerate=framerate,
            logging=logging,
            **options
        )

        self.__audio = None
        if enable_audio:
            self.__audio = AudioCapture(
                input_device=microphone_id,
                sample_rate=48000,
                channels=1,
                enable_output=True,
                logging=logging,
            )

        self.__peers: Dict[str, RTCConnection] = {}
        self.__peer_frames: Dict[str, NDArray] = {}
        self.__peer_audio: Dict[str, NDArray] = {}
        self.__frame_lock = threading.Lock()

        self.__on_remote_video: Optional[Callable[[str, NDArray], None]] = None
        self.__on_remote_audio: Optional[Callable[[str, NDArray], None]] = None
        self.__on_peer_connected: Optional[Callable[[str], None]] = None
        self.__on_peer_disconnected: Optional[Callable[[str], None]] = None

        self.__media_started = False

        self.__logging and logger.debug(
            "MultiPeerConference initialized: max {} peers".format(max_peers)
        )

    @property
    def peer_count(self) -> int:
        return len(self.__peers)

    @property
    def peer_names(self) -> list:
        return list(self.__peers.keys())

    @property
    def max_peers(self) -> int:
        return self.__max_peers

    def on_remote_video(self, callback: Callable[[str, NDArray], None]):
        self.__on_remote_video = callback
        return callback

    def on_remote_audio(self, callback: Callable[[str, NDArray], None]):
        self.__on_remote_audio = callback
        return callback

    def on_peer_connected(self, callback: Callable[[str], None]):
        self.__on_peer_connected = callback
        return callback

    def on_peer_disconnected(self, callback: Callable[[str], None]):
        self.__on_peer_disconnected = callback
        return callback

    def __start_local_media(self):
        if self.__media_started:
            return

        self.__logging and logger.debug("Starting local media devices")
        self.__video.start()
        if self.__audio:
            self.__audio.start()
        self.__media_started = True

    def __create_rtc_for_peer(self, peer_name: str) -> RTCConnection:
        rtc = RTCConnection(
            video_source=self.__video,
            audio_source=self.__audio,
            framerate=self.__framerate,
            enable_video=True,
            enable_audio=self.__enable_audio,
            ice_servers=STUN_ONLY_SERVERS,
            logging=self.__logging,
        )

        def make_video_handler(name):
            def handler(frame):
                with self.__frame_lock:
                    self.__peer_frames[name] = frame
                if self.__on_remote_video:
                    try:
                        self.__on_remote_video(name, frame)
                    except Exception as e:
                        logger.error("Error in video callback: {}".format(e))
            return handler

        def make_audio_handler(name):
            def handler(audio):
                with self.__frame_lock:
                    self.__peer_audio[name] = audio
                if self.__on_remote_audio:
                    try:
                        self.__on_remote_audio(name, audio)
                    except Exception as e:
                        logger.error("Error in audio callback: {}".format(e))
            return handler

        def make_state_handler(name):
            def handler(state):
                self.__logging and logger.info(
                    "Peer '{}' connection state: {}".format(name, state)
                )
                if state == "connected":
                    logger.critical("Connected to peer: {}".format(name))
                    if self.__on_peer_connected:
                        try:
                            self.__on_peer_connected(name)
                        except Exception as e:
                            logger.error("Error in connected callback: {}".format(e))
                elif state in ("failed", "disconnected", "closed"):
                    logger.warning("Peer '{}' disconnected".format(name))
                    if self.__on_peer_disconnected:
                        try:
                            self.__on_peer_disconnected(name)
                        except Exception as e:
                            logger.error("Error in disconnected callback: {}".format(e))
            return handler

        rtc.on_video_frame(make_video_handler(peer_name))
        rtc.on_audio_frame(make_audio_handler(peer_name))
        rtc.on_connection_state(make_state_handler(peer_name))

        return rtc

    def create_invite_for_peer(self, peer_name: str) -> str:
        if peer_name in self.__peers:
            raise RuntimeError(
                "Already have a connection for peer '{}'. "
                "Use a different name or remove the existing one.".format(peer_name)
            )

        if len(self.__peers) >= self.__max_peers:
            raise RuntimeError(
                "Maximum {} peers reached. Cannot add more.".format(self.__max_peers)
            )

        self.__start_local_media()

        rtc = self.__create_rtc_for_peer(peer_name)
        self.__peers[peer_name] = rtc

        offer = rtc.create_offer()
        invite_code = _compress_sdp(offer)

        self.__logging and logger.info(
            "Created invite for '{}' ({} chars)".format(peer_name, len(invite_code))
        )

        return invite_code

    def accept_invite_from_peer(self, peer_name: str, invite_code: str) -> str:
        if peer_name in self.__peers:
            raise RuntimeError(
                "Already have a connection for peer '{}'. "
                "Use a different name or remove the existing one.".format(peer_name)
            )

        if len(self.__peers) >= self.__max_peers:
            raise RuntimeError(
                "Maximum {} peers reached. Cannot add more.".format(self.__max_peers)
            )

        self.__start_local_media()

        rtc = self.__create_rtc_for_peer(peer_name)
        self.__peers[peer_name] = rtc

        offer = _decompress_sdp(invite_code)
        answer = rtc.create_answer(offer)
        response_code = _compress_sdp(answer)

        self.__logging and logger.info(
            "Created response for '{}' ({} chars)".format(peer_name, len(response_code))
        )

        return response_code

    def complete_connection_with_peer(self, peer_name: str, response_code: str):
        if peer_name not in self.__peers:
            raise RuntimeError(
                "No pending connection for peer '{}'. "
                "Call create_invite_for_peer() first.".format(peer_name)
            )

        answer = _decompress_sdp(response_code)
        self.__peers[peer_name].set_answer(answer)

        self.__logging and logger.info(
            "Completed connection handshake with '{}'".format(peer_name)
        )

    def remove_peer(self, peer_name: str):
        if peer_name not in self.__peers:
            return

        self.__logging and logger.debug("Removing peer: {}".format(peer_name))

        rtc = self.__peers.pop(peer_name)
        rtc.stop()

        with self.__frame_lock:
            self.__peer_frames.pop(peer_name, None)
            self.__peer_audio.pop(peer_name, None)

    def get_local_frame(self) -> Optional[NDArray]:
        if not self.__media_started:
            return None
        return self.__video.read()

    def get_peer_frame(self, peer_name: str) -> Optional[NDArray]:
        with self.__frame_lock:
            return self.__peer_frames.get(peer_name)

    def get_all_peer_frames(self) -> Dict[str, NDArray]:
        with self.__frame_lock:
            return dict(self.__peer_frames)

    def get_peer_audio(self, peer_name: str) -> Optional[NDArray]:
        with self.__frame_lock:
            return self.__peer_audio.get(peer_name)

    def wait_for_peer(self, peer_name: str, timeout: float = 30.0) -> bool:
        if peer_name not in self.__peers:
            return False

        rtc = self.__peers[peer_name]
        start = time.time()
        while (time.time() - start) < timeout:
            if rtc.connection_state == "connected":
                return True
            time.sleep(0.1)
        return False

    def stop(self):
        self.__logging and logger.debug("Stopping MultiPeerConference")

        for peer_name in list(self.__peers.keys()):
            self.remove_peer(peer_name)

        if self.__media_started:
            self.__video.stop()
            if self.__audio:
                self.__audio.stop()
            self.__media_started = False

        self.__logging and logger.debug("MultiPeerConference stopped")
```

---

## File: conference/peer.py

```python
import json
import base64
import zlib
import threading
import time
import logging as log
from typing import Optional, Callable, Tuple
import numpy as np
from numpy.typing import NDArray

from ..stream.video import VideoStream
from ..capture.audio import AudioCapture
from ..rtc.connection import RTCConnection
from ..utils.common import logger_handler, log_version

logger = log.getLogger("PeerConference")
logger.propagate = False
logger.addHandler(logger_handler())
logger.setLevel(log.DEBUG)

STUN_ONLY_SERVERS = [
    {"urls": ["stun:stun.l.google.com:19302"]},
    {"urls": ["stun:stun1.l.google.com:19302"]},
    {"urls": ["stun:stun.stunprotocol.org:3478"]},
]


def _compress_sdp(sdp_dict: dict) -> str:
    json_bytes = json.dumps(sdp_dict, separators=(',', ':')).encode('utf-8')
    compressed = zlib.compress(json_bytes, level=9)
    return base64.urlsafe_b64encode(compressed).decode('ascii')


def _decompress_sdp(code: str) -> dict:
    try:
        compressed = base64.urlsafe_b64decode(code.encode('ascii'))
        json_bytes = zlib.decompress(compressed)
        return json.loads(json_bytes.decode('utf-8'))
    except Exception as e:
        raise ValueError(
            "Invalid code. Make sure you copied the entire code correctly."
        ) from e


class PeerConference:

    def __init__(
        self,
        resolution: Tuple[int, int] = (1920, 1080),
        framerate: int = 30,
        enable_audio: bool = True,
        camera_id: int = 0,
        microphone_id: Optional[int] = None,
        use_stun: bool = True,
        logging: bool = False,
        **options: dict
    ):
        self.__logging = logging if isinstance(logging, bool) else False

        log_version(logging=self.__logging)

        self.__resolution = resolution
        self.__framerate = framerate
        self.__enable_audio = enable_audio

        self.__ice_servers = STUN_ONLY_SERVERS if use_stun else []

        options = {str(k).strip(): v for k, v in options.items()}

        self.__video = VideoStream(
            source=camera_id,
            resolution=resolution,
            framerate=framerate,
            logging=logging,
            **options
        )

        self.__audio = None
        if enable_audio:
            self.__audio = AudioCapture(
                input_device=microphone_id,
                sample_rate=48000,
                channels=1,
                enable_output=True,
                logging=logging,
            )

        self.__rtc: Optional[RTCConnection] = None

        self.__is_initiator = False
        self.__is_connected = False
        self.__is_streaming = False
        self.__media_started = False

        self.__on_remote_video: Optional[Callable[[NDArray], None]] = None
        self.__on_remote_audio: Optional[Callable[[NDArray], None]] = None
        self.__on_connected: Optional[Callable[[], None]] = None
        self.__on_disconnected: Optional[Callable[[], None]] = None

        self.__last_remote_frame: Optional[NDArray] = None
        self.__last_remote_audio: Optional[NDArray] = None
        self.__frame_lock = threading.Lock()

        self.__logging and logger.debug(
            "PeerConference initialized: {}x{} @ {}fps, audio={}".format(
                resolution[0], resolution[1], framerate, enable_audio
            )
        )

    @property
    def is_connected(self) -> bool:
        return self.__is_connected

    @property
    def is_streaming(self) -> bool:
        return self.__is_streaming

    @property
    def resolution(self) -> Tuple[int, int]:
        return self.__resolution

    @property
    def framerate(self) -> int:
        return self.__framerate

    def on_remote_video(self, callback: Callable[[NDArray], None]):
        self.__on_remote_video = callback
        return callback

    def on_remote_audio(self, callback: Callable[[NDArray], None]):
        self.__on_remote_audio = callback
        return callback

    def on_connected(self, callback: Callable[[], None]):
        self.__on_connected = callback
        return callback

    def on_disconnected(self, callback: Callable[[], None]):
        self.__on_disconnected = callback
        return callback

    def __start_local_media(self):
        if self.__media_started:
            return

        self.__logging and logger.debug("Starting local media devices")
        self.__video.start()
        if self.__audio:
            self.__audio.start()
        self.__media_started = True

    def __setup_rtc(self):
        self.__rtc = RTCConnection(
            video_source=self.__video,
            audio_source=self.__audio,
            framerate=self.__framerate,
            sample_rate=48000,
            audio_channels=1,
            enable_video=True,
            enable_audio=self.__enable_audio,
            ice_servers=self.__ice_servers,
            logging=self.__logging,
        )

        def handle_video(frame: NDArray):
            with self.__frame_lock:
                self.__last_remote_frame = frame
            if self.__on_remote_video:
                try:
                    self.__on_remote_video(frame)
                except Exception as e:
                    logger.error("Error in video callback: {}".format(e))

        def handle_audio(audio: NDArray):
            with self.__frame_lock:
                self.__last_remote_audio = audio
            if self.__on_remote_audio:
                try:
                    self.__on_remote_audio(audio)
                except Exception as e:
                    logger.error("Error in audio callback: {}".format(e))

        def handle_state(state: str):
            self.__logging and logger.info("Connection state: {}".format(state))
            if state == "connected":
                self.__is_connected = True
                logger.critical("Peer-to-peer connection established!")
                if self.__on_connected:
                    try:
                        self.__on_connected()
                    except Exception as e:
                        logger.error("Error in connected callback: {}".format(e))
            elif state in ("failed", "disconnected", "closed"):
                was_connected = self.__is_connected
                self.__is_connected = False
                if was_connected:
                    logger.warning("Connection lost: {}".format(state))
                    if self.__on_disconnected:
                        try:
                            self.__on_disconnected()
                        except Exception as e:
                            logger.error("Error in disconnected callback: {}".format(e))

        self.__rtc.on_video_frame(handle_video)
        self.__rtc.on_audio_frame(handle_audio)
        self.__rtc.on_connection_state(handle_state)

    def create_invite(self) -> str:
        if self.__rtc is not None:
            raise RuntimeError(
                "Already in a session. Call stop() first to start a new one."
            )

        self.__is_initiator = True

        self.__start_local_media()

        self.__setup_rtc()

        self.__logging and logger.debug("Creating WebRTC offer...")

        offer = self.__rtc.create_offer()

        invite_code = _compress_sdp(offer)

        self.__logging and logger.info(
            "Created invite code ({} characters)".format(len(invite_code))
        )

        return invite_code

    def accept_invite(self, invite_code: str) -> str:
        if self.__rtc is not None:
            raise RuntimeError(
                "Already in a session. Call stop() first to start a new one."
            )

        self.__is_initiator = False

        self.__start_local_media()

        self.__setup_rtc()

        self.__logging and logger.debug("Decoding invite code...")
        offer = _decompress_sdp(invite_code)

        self.__logging and logger.debug("Creating WebRTC answer...")

        answer = self.__rtc.create_answer(offer)

        response_code = _compress_sdp(answer)

        self.__logging and logger.info(
            "Created response code ({} characters)".format(len(response_code))
        )

        self.__is_streaming = True

        return response_code

    def complete_connection(self, response_code: str):
        if not self.__is_initiator:
            raise RuntimeError(
                "Only the person who created the invite should call complete_connection(). "
                "If you're joining, your connection starts automatically after accept_invite()."
            )

        if self.__rtc is None:
            raise RuntimeError(
                "Must call create_invite() first before complete_connection()."
            )

        self.__logging and logger.debug("Decoding response code...")
        answer = _decompress_sdp(response_code)

        self.__logging and logger.debug("Setting remote answer...")
        self.__rtc.set_answer(answer)

        self.__is_streaming = True
        self.__logging and logger.info(
            "Connection process started. Waiting for peer-to-peer link..."
        )

    def get_local_frame(self) -> Optional[NDArray]:
        if not self.__media_started:
            return None
        return self.__video.read()

    def get_remote_frame(self) -> Optional[NDArray]:
        with self.__frame_lock:
            return self.__last_remote_frame

    def get_remote_audio(self) -> Optional[NDArray]:
        with self.__frame_lock:
            return self.__last_remote_audio

    def wait_for_connection(self, timeout: float = 30.0) -> bool:
        start = time.time()
        while not self.__is_connected and (time.time() - start) < timeout:
            time.sleep(0.1)
        return self.__is_connected

    def stop(self):
        self.__logging and logger.debug("Stopping PeerConference")

        self.__is_streaming = False
        self.__is_connected = False

        if self.__rtc:
            self.__rtc.stop()
            self.__rtc = None

        if self.__media_started:
            self.__video.stop()
            if self.__audio:
                self.__audio.stop()
            self.__media_started = False

        with self.__frame_lock:
            self.__last_remote_frame = None
            self.__last_remote_audio = None

        self.__logging and logger.debug("PeerConference stopped")
```

---

## File: net/__init__.py

```python
from .sync import SyncTransport
from .async_ import AsyncTransport

__all__ = ["SyncTransport", "AsyncTransport"]
```

---

## File: net/async_.py

```python
import numpy as np
import asyncio
import inspect
import logging as log
import string
import secrets
import platform
import threading
from typing import Any, Tuple, AsyncGenerator, Union, TypeVar
from numpy.typing import NDArray

from ..utils.common import logger_handler, import_dependency_safe, log_version
from ..stream.video import VideoStream

zmq = import_dependency_safe("zmq", pkg_name="pyzmq", error="silent", min_version="4.0")
if not (zmq is None):
    import zmq.asyncio
msgpack = import_dependency_safe("msgpack", error="silent")
m = import_dependency_safe("msgpack_numpy", error="silent")
uvloop = import_dependency_safe("uvloop", error="silent")

logger = log.getLogger("AsyncTransport")
logger.propagate = False
logger.addHandler(logger_handler())
logger.setLevel(log.DEBUG)

T = TypeVar("T", bound="AsyncTransport")


class AsyncTransport:

    def __init__(
        self,
        address: str = None,
        port: str = None,
        protocol: str = "tcp",
        pattern: int = 0,
        receive_mode: bool = False,
        timeout: Union[int, float] = 0.0,
        source: Any = None,
        backend: int = 0,
        colorspace: str = None,
        resolution: Tuple[int, int] = (640, 480),
        framerate: Union[int, float] = 25,
        time_delay: int = 0,
        logging: bool = False,
        gpu_accelerated: bool = False,
        gpu_id: int = 0,
        gpu_bitrate: int = 8000000,
        gpu_codec: str = "h264",
        **options: dict
    ):
        self.__logging = logging if isinstance(logging, bool) else False

        log_version(logging=self.__logging)

        import_dependency_safe(
            "zmq" if zmq is None else "", min_version="4.0", pkg_name="pyzmq"
        )
        import_dependency_safe("msgpack" if msgpack is None else "")
        import_dependency_safe("msgpack_numpy" if m is None else "")

        self.__gpu_accelerated = False
        self.__gpu_id = gpu_id
        self.__gpu_bitrate = gpu_bitrate
        self.__gpu_codec = gpu_codec
        self.__nvidia_encoder = None
        self.__nvidia_decoder = None
        self.__resolution = resolution

        if gpu_accelerated:
            try:
                from ..utils.nvidia_codec import has_nvidia_codec, NvidiaEncoder, NvidiaDecoder
                if has_nvidia_codec():
                    self.__gpu_accelerated = True
                    self.__logging and logger.info("GPU acceleration enabled with NVIDIA hardware encoding")
                else:
                    logger.warning("GPU acceleration requested but NVIDIA codec not available. Falling back to CPU.")
            except ImportError as e:
                logger.warning("GPU acceleration requested but PyNvVideoCodec not installed: {}. Falling back to CPU.".format(e))

        valid_messaging_patterns = {
            0: (zmq.PAIR, zmq.PAIR),
            1: (zmq.REQ, zmq.REP),
            2: (zmq.PUB, zmq.SUB),
            3: (zmq.PUSH, zmq.PULL),
        }

        if isinstance(pattern, int) and pattern in valid_messaging_patterns:
            self.__msg_pattern = pattern
            self.__pattern = valid_messaging_patterns[pattern]
        else:
            self.__msg_pattern = 0
            self.__pattern = valid_messaging_patterns[self.__msg_pattern]
            self.__logging and logger.warning(
                "Invalid pattern {pattern}. Defaulting to `zmq.PAIR`!".format(
                    pattern=pattern
                )
            )

        if isinstance(protocol, str) and protocol in ["tcp", "ipc"]:
            self.__protocol = protocol
        else:
            self.__protocol = "tcp"
            self.__logging and logger.warning("Invalid protocol. Defaulting to `tcp`!")

        self.__terminate = False
        self.__receive_mode = receive_mode
        self.__stream = None
        self.__msg_socket = None
        self.config = {}
        self.__queue = None
        self.__bi_mode = False

        if timeout and isinstance(timeout, (int, float)):
            self.__timeout = float(timeout)
        else:
            self.__timeout = 15.0

        self.__id = "".join(
            secrets.choice(string.ascii_uppercase + string.digits) for i in range(8)
        )

        options = {str(k).strip(): v for k, v in options.items()}

        if "bidirectional_mode" in options:
            value = options["bidirectional_mode"]
            if isinstance(value, bool) and pattern < 2 and source is None:
                self.__bi_mode = value
            else:
                self.__bi_mode = False
                logger.warning("Bidirectional data transmission is disabled!")
            if pattern >= 2:
                raise ValueError(
                    "[AsyncTransport:ERROR] :: `{}` pattern is not valid when Bidirectional Mode is enabled. Kindly refer Docs for more Information!".format(
                        pattern
                    )
                )
            elif not (source is None):
                raise ValueError(
                    "[AsyncTransport:ERROR] :: Custom source must be None when Bidirectional Mode is enabled. Kindly refer Docs for more Information!"
                )
            elif isinstance(value, bool) and self.__logging:
                logger.debug(
                    "Bidirectional Data Transmission is {} for this connection!".format(
                        "enabled" if value else "disabled"
                    )
                )
            else:
                logger.error("`bidirectional_mode` value is invalid!")
            del options["bidirectional_mode"]

        self.__loop_thread = None
        self.__owns_loop = False

        if platform.system() == "Windows":
            asyncio.set_event_loop_policy(asyncio.WindowsSelectorEventLoopPolicy())
        else:
            if not (uvloop is None):
                asyncio.set_event_loop_policy(uvloop.EventLoopPolicy())
            else:
                import_dependency_safe("uvloop", error="log")

        try:
            self.loop = asyncio.get_running_loop()
            self.__owns_loop = False
        except RuntimeError:
            self.loop = asyncio.new_event_loop()
            self.__owns_loop = True
            self.__loop_thread = threading.Thread(target=self.__run_loop, daemon=True)
            self.__loop_thread.start()
            self.__logging and logger.debug("Started background event loop thread.")

        self.__logging and logger.info(
            "Using ``{}`` event loop for this process.".format(
                self.loop.__class__.__name__
            )
        )

        self.__msg_context = zmq.asyncio.Context()

        if receive_mode:
            if address is None:
                self.__address = "*"
            else:
                self.__address = address
            if port is None:
                self.__port = "5555"
            else:
                self.__port = port
        else:
            if source is None:
                self.config = {"generator": None}
                self.__logging and logger.warning("Given source is of NoneType!")
            else:
                self.__stream = VideoStream(
                    source=source,
                    backend=backend,
                    colorspace=colorspace,
                    resolution=resolution,
                    framerate=framerate,
                    logging=logging,
                    time_delay=time_delay,
                    **options
                )
                self.config = {"generator": self.__frame_generator()}
            if address is None:
                self.__address = "localhost"
            else:
                self.__address = address
            if port is None:
                self.__port = "5555"
            else:
                self.__port = port
            self.task = None

        self.__queue = asyncio.Queue() if self.__bi_mode else None

    def __run_loop(self):
        asyncio.set_event_loop(self.loop)
        self.loop.run_forever()

    def __get_nvidia_encoder(self, width: int, height: int):
        if self.__nvidia_encoder is None:
            from ..utils.nvidia_codec import NvidiaEncoder
            self.__nvidia_encoder = NvidiaEncoder(
                width=width,
                height=height,
                bitrate=self.__gpu_bitrate,
                codec=self.__gpu_codec,
                gpu_id=self.__gpu_id,
                logging=self.__logging,
            )
        return self.__nvidia_encoder

    def __get_nvidia_decoder(self):
        if self.__nvidia_decoder is None:
            from ..utils.nvidia_codec import NvidiaDecoder
            self.__nvidia_decoder = NvidiaDecoder(
                gpu_id=self.__gpu_id,
                logging=self.__logging,
            )
        return self.__nvidia_decoder

    def launch(self) -> T:
        if self.__receive_mode:
            self.__logging and logger.debug(
                "Launching AsyncTransport asynchronous generator!"
            )
        else:
            self.__logging and logger.debug(
                "Creating AsyncTransport asynchronous server handler!"
            )
            if self.__owns_loop:
                self.task = asyncio.run_coroutine_threadsafe(
                    self.__server_handler(), self.loop
                )
            else:
                self.task = self.loop.create_task(self.__server_handler())
        return self

    async def __server_handler(self):
        if isinstance(self.config, dict) and "generator" in self.config:
            if self.config["generator"] is None or not inspect.isasyncgen(
                self.config["generator"]
            ):
                raise ValueError(
                    "[AsyncTransport:ERROR] :: Invalid configuration. Assigned generator must be a asynchronous generator function/method only!"
                )
        else:
            raise RuntimeError(
                "[AsyncTransport:ERROR] :: Assigned AsyncTransport configuration is invalid!"
            )

        self.__msg_socket = self.__msg_context.socket(self.__pattern[0])

        if self.__msg_pattern == 1:
            self.__msg_socket.REQ_RELAXED = True
            self.__msg_socket.REQ_CORRELATE = True

        if self.__msg_pattern == 2:
            self.__msg_socket.set_hwm(1)

        try:
            self.__msg_socket.connect(
                self.__protocol + "://" + str(self.__address) + ":" + str(self.__port)
            )
            self.__logging and logger.debug(
                "Successfully connected to address: {} with pattern: {}.".format(
                    (
                        self.__protocol
                        + "://"
                        + str(self.__address)
                        + ":"
                        + str(self.__port)
                    ),
                    self.__msg_pattern,
                )
            )
            if self.__gpu_accelerated:
                logger.critical(
                    "Send Mode is successfully activated with GPU acceleration and ready to send data!"
                )
            else:
                logger.critical(
                    "Send Mode is successfully activated and ready to send data!"
                )
        except Exception as e:
            logger.exception(str(e))
            if self.__bi_mode:
                logger.error(
                    "Failed to activate Bidirectional Mode for this connection!"
                )
            raise ValueError(
                "[AsyncTransport:ERROR] :: Failed to connect address: {} and pattern: {}!".format(
                    (
                        self.__protocol
                        + "://"
                        + str(self.__address)
                        + ":"
                        + str(self.__port)
                    ),
                    self.__msg_pattern,
                )
            )

        async for dataframe in self.config["generator"]:
            if self.__bi_mode and len(dataframe) == 2:
                (data, frame) = dataframe
                if not (data is None) and isinstance(data, np.ndarray):
                    logger.warning(
                        "Skipped unsupported `data` of datatype: {}!".format(
                            type(data).__name__
                        )
                    )
                    data = None
                assert isinstance(
                    frame, np.ndarray
                ), "[AsyncTransport:ERROR] :: Invalid data received from server end!"
            elif self.__bi_mode:
                raise ValueError(
                    "[AsyncTransport:ERROR] :: Send Mode only accepts tuple(data, frame) as input in Bidirectional Mode. \
                    Kindly refer VideoConference4k docs!"
                )
            else:
                frame = np.copy(dataframe)
                data = None

            if not (frame.flags["C_CONTIGUOUS"]):
                frame = np.ascontiguousarray(frame, dtype=frame.dtype)

            if self.__gpu_accelerated:
                encoder = self.__get_nvidia_encoder(frame.shape[1], frame.shape[0])
                encoded_frame = encoder.encode(frame)

                data_dict = dict(
                    terminate=False,
                    bi_mode=self.__bi_mode,
                    data=data if not (data is None) else "",
                    gpu_accelerated=True,
                    gpu_codec=self.__gpu_codec,
                    width=frame.shape[1],
                    height=frame.shape[0],
                )
                data_enc = msgpack.packb(data_dict)
                await self.__msg_socket.send(data_enc, flags=zmq.SNDMORE)
                await self.__msg_socket.send_multipart([encoded_frame])
            else:
                data_dict = dict(
                    terminate=False,
                    bi_mode=self.__bi_mode,
                    data=data if not (data is None) else "",
                    gpu_accelerated=False,
                )
                data_enc = msgpack.packb(data_dict)
                await self.__msg_socket.send(data_enc, flags=zmq.SNDMORE)

                frame_enc = msgpack.packb(frame, default=m.encode)
                await self.__msg_socket.send_multipart([frame_enc])

            if self.__msg_pattern < 2:
                if self.__bi_mode:
                    recvdmsg_encoded = await asyncio.wait_for(
                        self.__msg_socket.recv(), timeout=self.__timeout
                    )
                    recvd_data = msgpack.unpackb(recvdmsg_encoded, use_list=False)

                    if recvd_data.get("gpu_accelerated"):
                        recvdframe_encoded = await asyncio.wait_for(
                            self.__msg_socket.recv_multipart(), timeout=self.__timeout
                        )
                        decoder = self.__get_nvidia_decoder()
                        decoded_frame = decoder.decode(
                            bytes(recvdframe_encoded[0]),
                            width=recvd_data.get("width"),
                            height=recvd_data.get("height")
                        )
                        if decoded_frame is None:
                            raise RuntimeError(
                                "[AsyncTransport:ERROR] :: Received NVENC frame decoding failed. "
                                "Width: {}, Height: {}".format(
                                    recvd_data.get("width"),
                                    recvd_data.get("height")
                                )
                            )
                        await self.__queue.put(decoded_frame)
                    elif recvd_data.get("return_type") == "ndarray":
                        recvdframe_encoded = await asyncio.wait_for(
                            self.__msg_socket.recv_multipart(), timeout=self.__timeout
                        )
                        await self.__queue.put(
                            msgpack.unpackb(
                                recvdframe_encoded[0],
                                use_list=False,
                                object_hook=m.decode,
                            )
                        )
                    else:
                        await self.__queue.put(
                            recvd_data.get("return_data")
                            if recvd_data.get("return_data")
                            else None
                        )
                else:
                    recv_confirmation = await asyncio.wait_for(
                        self.__msg_socket.recv(), timeout=self.__timeout
                    )
                    self.__logging and logger.debug(recv_confirmation)

    async def recv_generator(self) -> AsyncGenerator[Tuple[Any, NDArray], NDArray]:
        if not (self.__receive_mode):
            self.__terminate = True
            raise ValueError(
                "[AsyncTransport:ERROR] :: `recv_generator()` function cannot be accessed while `receive_mode` is disabled. Kindly refer VideoConference4k docs!"
            )

        self.__msg_socket = self.__msg_context.socket(self.__pattern[1])

        if self.__msg_pattern == 2:
            self.__msg_socket.set_hwm(1)
            self.__msg_socket.setsockopt(zmq.SUBSCRIBE, b"")

        try:
            self.__msg_socket.bind(
                self.__protocol + "://" + str(self.__address) + ":" + str(self.__port)
            )
            self.__logging and logger.debug(
                "Successfully binded to address: {} with pattern: {}.".format(
                    (
                        self.__protocol
                        + "://"
                        + str(self.__address)
                        + ":"
                        + str(self.__port)
                    ),
                    self.__msg_pattern,
                )
            )
            if self.__gpu_accelerated:
                logger.critical("Receive Mode is activated successfully with GPU acceleration!")
            else:
                logger.critical("Receive Mode is activated successfully!")
        except Exception as e:
            logger.exception(str(e))
            raise RuntimeError(
                "[AsyncTransport:ERROR] :: Failed to bind address: {} and pattern: {}{}!".format(
                    (
                        self.__protocol
                        + "://"
                        + str(self.__address)
                        + ":"
                        + str(self.__port)
                    ),
                    self.__msg_pattern,
                    " and Bidirectional Mode enabled" if self.__bi_mode else "",
                )
            )

        while not self.__terminate:
            datamsg_encoded = await asyncio.wait_for(
                self.__msg_socket.recv(), timeout=self.__timeout
            )
            data = msgpack.unpackb(datamsg_encoded, use_list=False)
            if data.get("terminate", False):
                if self.__msg_pattern < 2:
                    return_dict = dict(
                        terminated="Client-`{}` successfully terminated!".format(
                            self.__id
                        ),
                    )
                    retdata_enc = msgpack.packb(return_dict)
                    await self.__msg_socket.send(retdata_enc)
                self.__logging and logger.info(
                    "Termination signal received from server!"
                )
                self.__terminate = True
                break

            framemsg_encoded = await asyncio.wait_for(
                self.__msg_socket.recv_multipart(), timeout=self.__timeout
            )

            if data.get("gpu_accelerated"):
                decoder = self.__get_nvidia_decoder()
                frame = decoder.decode(
                    bytes(framemsg_encoded[0]),
                    width=data.get("width"),
                    height=data.get("height")
                )
                if frame is None:
                    raise RuntimeError(
                        "[AsyncTransport:ERROR] :: Received NVENC frame decoding failed. "
                        "Width: {}, Height: {}".format(
                            data.get("width"),
                            data.get("height")
                        )
                    )
            else:
                frame = msgpack.unpackb(
                    framemsg_encoded[0], use_list=False, object_hook=m.decode
                )

            if self.__msg_pattern < 2:
                if self.__bi_mode and data.get("bi_mode", False):
                    if not self.__queue.empty():
                        return_data = await self.__queue.get()
                        self.__queue.task_done()
                    else:
                        return_data = None
                    if not (return_data is None) and isinstance(
                        return_data, np.ndarray
                    ):
                        if not (return_data.flags["C_CONTIGUOUS"]):
                            return_data = np.ascontiguousarray(
                                return_data, dtype=return_data.dtype
                            )

                        if self.__gpu_accelerated:
                            encoder = self.__get_nvidia_encoder(
                                return_data.shape[1], return_data.shape[0]
                            )
                            encoded_return = encoder.encode(return_data)

                            rettype_dict = dict(
                                return_type=(type(return_data).__name__),
                                return_data=None,
                                gpu_accelerated=True,
                                gpu_codec=self.__gpu_codec,
                                width=return_data.shape[1],
                                height=return_data.shape[0],
                            )
                            rettype_enc = msgpack.packb(rettype_dict)
                            await self.__msg_socket.send(rettype_enc, flags=zmq.SNDMORE)
                            await self.__msg_socket.send_multipart([encoded_return])
                        else:
                            rettype_dict = dict(
                                return_type=(type(return_data).__name__),
                                return_data=None,
                                gpu_accelerated=False,
                            )
                            rettype_enc = msgpack.packb(rettype_dict)
                            await self.__msg_socket.send(rettype_enc, flags=zmq.SNDMORE)

                            retframe_enc = msgpack.packb(return_data, default=m.encode)
                            await self.__msg_socket.send_multipart([retframe_enc])
                    else:
                        return_dict = dict(
                            return_type=(type(return_data).__name__),
                            return_data=(
                                return_data if not (return_data is None) else ""
                            ),
                            gpu_accelerated=False,
                        )
                        retdata_enc = msgpack.packb(return_dict)
                        await self.__msg_socket.send(retdata_enc)
                elif self.__bi_mode or data.get("bi_mode", False):
                    raise RuntimeError(
                        "[AsyncTransport:ERROR] :: Invalid configuration! Bidirectional Mode is not activate on {} end.".format(
                            "client" if self.__bi_mode else "server"
                        )
                    )
                else:
                    await self.__msg_socket.send(
                        bytes(
                            "Data received on client: {} !".format(self.__id), "utf-8"
                        )
                    )
            if self.__bi_mode:
                yield (data.get("data"), frame) if data.get("data") else (None, frame)
            else:
                yield frame
            await asyncio.sleep(0)

    async def __frame_generator(self):
        self.__stream.start()
        while not self.__terminate:
            frame = self.__stream.read()
            if frame is None:
                break
            yield frame
            await asyncio.sleep(0)

    async def transceive_data(self, data: Any = None) -> Any:
        recvd_data = None
        if not self.__terminate:
            if self.__bi_mode:
                if self.__receive_mode:
                    await self.__queue.put(data)
                else:
                    if not self.__queue.empty():
                        recvd_data = await self.__queue.get()
                        self.__queue.task_done()
            else:
                logger.error(
                    "`transceive_data()` function cannot be used when Bidirectional Mode is disabled."
                )
        return recvd_data

    async def __terminate_connection(self, disable_confirmation=False):
        self.__logging and logger.debug(
            "Terminating various {} Processes. Please wait.".format(
                "Receive Mode" if self.__receive_mode else "Send Mode"
            )
        )

        if self.__nvidia_encoder is not None:
            self.__nvidia_encoder.close()
            self.__nvidia_encoder = None

        if self.__nvidia_decoder is not None:
            self.__nvidia_decoder.close()
            self.__nvidia_decoder = None

        if self.__receive_mode:
            self.__terminate = True
        else:
            self.__terminate = True
            if not (self.__stream is None):
                self.__stream.stop()
            data_dict = dict(terminate=True)
            data_enc = msgpack.packb(data_dict)
            await self.__msg_socket.send(data_enc)
            if self.__msg_pattern < 2 and not disable_confirmation:
                recv_confirmation = await self.__msg_socket.recv()
                recvd_conf = msgpack.unpackb(recv_confirmation, use_list=False)
                self.__logging and "terminated" in recvd_conf and logger.debug(
                    recvd_conf["terminated"]
                )
        self.__msg_socket.setsockopt(zmq.LINGER, 0)
        self.__msg_socket.close()
        if self.__bi_mode:
            while not self.__queue.empty():
                try:
                    self.__queue.get_nowait()
                except asyncio.QueueEmpty:
                    continue
                self.__queue.task_done()
            await self.__queue.join()

        logger.critical(
            "{} successfully terminated!".format(
                "Receive Mode" if self.__receive_mode else "Send Mode"
            )
        )

    def close(self, skip_loop: bool = False) -> None:
        if not (skip_loop):
            if self.__owns_loop:
                future = asyncio.run_coroutine_threadsafe(
                    self.__terminate_connection(), self.loop
                )
                try:
                    future.result(timeout=10)
                except Exception as e:
                    logger.error("Error during close: {}".format(e))
                self.loop.call_soon_threadsafe(self.loop.stop)
                if self.__loop_thread is not None:
                    self.__loop_thread.join(timeout=2)
            else:
                if self.loop is not None and self.loop.is_running():
                    future = asyncio.run_coroutine_threadsafe(
                        self.__terminate_connection(), self.loop
                    )
                    try:
                        future.result(timeout=10)
                    except Exception as e:
                        logger.error("Error during close: {}".format(e))
                else:
                    try:
                        new_loop = asyncio.new_event_loop()
                        asyncio.set_event_loop(new_loop)
                        new_loop.run_until_complete(self.__terminate_connection())
                        new_loop.close()
                    except Exception as e:
                        logger.error("Error during close: {}".format(e))
        else:
            if self.loop is not None and self.loop.is_running():
                asyncio.run_coroutine_threadsafe(
                    self.__terminate_connection(disable_confirmation=True),
                    self.loop
                )
            else:
                try:
                    new_loop = asyncio.new_event_loop()
                    asyncio.set_event_loop(new_loop)
                    new_loop.run_until_complete(
                        self.__terminate_connection(disable_confirmation=True)
                    )
                    new_loop.close()
                except Exception as e:
                    logger.error("Error during async close: {}".format(e))
```

---

## File: net/sync.py

```python
import os
import time
import asyncio
import platform
import string
import secrets
import numpy as np
import logging as log
from threading import Thread, Lock, Event
from collections import deque
from os.path import expanduser
from numpy.typing import NDArray
from typing import Optional, Any, Tuple

from ..utils.common import (
    logger_handler,
    generate_auth_certificates,
    check_WriteAccess,
    check_open_port,
    import_dependency_safe,
    log_version,
)

zmq = import_dependency_safe("zmq", pkg_name="pyzmq", error="silent", min_version="4.0")
if not (zmq is None):
    from zmq import ssh
    from zmq import auth
    from zmq.auth.thread import ThreadAuthenticator
    from zmq.error import ZMQError
simplejpeg = import_dependency_safe("simplejpeg", error="silent", min_version="1.6.1")
paramiko = import_dependency_safe("paramiko", error="silent")

logger = log.getLogger("SyncTransport")
logger.propagate = False
logger.addHandler(logger_handler())
logger.setLevel(log.DEBUG)


class SyncTransport:

    def __init__(
        self,
        address: str = None,
        port: str = None,
        protocol: str = None,
        pattern: int = 0,
        receive_mode: bool = False,
        logging: bool = False,
        gpu_accelerated: bool = False,
        gpu_id: int = 0,
        gpu_resolution: Tuple[int, int] = None,
        gpu_bitrate: int = 8000000,
        gpu_codec: str = "h264",
        **options: dict
    ):
        self.__logging = logging if isinstance(logging, bool) else False

        log_version(logging=self.__logging)

        import_dependency_safe(
            "zmq" if zmq is None else "", min_version="4.0", pkg_name="pyzmq"
        )
        import_dependency_safe(
            "simplejpeg" if simplejpeg is None else "", error="log", min_version="1.6.1"
        )

        self.__gpu_accelerated = False
        self.__gpu_id = gpu_id
        self.__gpu_resolution = gpu_resolution
        self.__gpu_bitrate = gpu_bitrate
        self.__gpu_codec = gpu_codec
        self.__nvidia_encoder = None
        self.__nvidia_decoder = None

        if gpu_accelerated:
            try:
                from ..utils.nvidia_codec import has_nvidia_codec, NvidiaEncoder, NvidiaDecoder
                if has_nvidia_codec():
                    self.__gpu_accelerated = True
                    self.__logging and logger.info("GPU acceleration enabled with NVIDIA hardware encoding")
                else:
                    logger.warning("GPU acceleration requested but NVIDIA codec not available. Falling back to CPU.")
            except ImportError as e:
                logger.warning("GPU acceleration requested but PyNvVideoCodec not installed: {}. Falling back to CPU.".format(e))

        valid_messaging_patterns = {
            0: (zmq.PAIR, zmq.PAIR),
            1: (zmq.REQ, zmq.REP),
            2: (zmq.PUB, zmq.SUB),
        }

        msg_pattern = None
        if isinstance(pattern, int) and pattern in valid_messaging_patterns.keys():
            msg_pattern = valid_messaging_patterns[pattern]
        else:
            pattern = 0
            msg_pattern = valid_messaging_patterns[pattern]
            self.__logging and logger.warning(
                "Wrong pattern value, Defaulting to `zmq.PAIR`! Kindly refer Docs for more Information."
            )
        self.__pattern = pattern

        if protocol is None or not (protocol in ["tcp", "ipc"]):
            protocol = "tcp"
            self.__logging and logger.warning(
                "Protocol is not supported or not provided. Defaulting to `tcp` protocol!"
            )

        self.__msg_flag = 0
        self.__msg_copy = False
        self.__msg_track = False

        self.__z_auth = None

        self.__ssh_tunnel_mode = None
        self.__ssh_tunnel_pwd = None
        self.__ssh_tunnel_keyfile = None
        self.__paramiko_present = False if paramiko is None else True

        self.__multiserver_mode = False

        self.__multiclient_mode = False

        self.__bi_mode = False

        valid_security_mech = {0: "Grasslands", 1: "StoneHouse", 2: "IronHouse"}
        self.__secure_mode = 0
        auth_cert_dir = ""
        self.__auth_publickeys_dir = ""
        self.__auth_secretkeys_dir = ""
        overwrite_cert = False
        custom_cert_location = ""

        self.__jpeg_compression = (
            True if not (simplejpeg is None) and not self.__gpu_accelerated else False
        )
        self.__jpeg_compression_quality = 90
        self.__jpeg_compression_fastdct = True
        self.__jpeg_compression_fastupsample = False
        self.__jpeg_compression_colorspace = "BGR"

        self.__ex_compression_params = None

        self.__return_data = None
        self.__return_data_lock = Lock()

        self.__id = "".join(
            secrets.choice(string.ascii_uppercase + string.digits) for i in range(8)
        )

        self.__terminate = Event()

        if pattern < 2:
            self.__poll = zmq.Poller()
            self.__max_retries = 3
            self.__request_timeout = 4000
        else:
            self.__subscriber_timeout = None

        options = {str(k).strip(): v for k, v in options.items()}

        for key, value in options.items():
            if key == "multiserver_mode" and isinstance(value, bool):
                if pattern > 0:
                    self.__multiserver_mode = value
                else:
                    self.__multiserver_mode = False
                    logger.critical("Multi-Server Mode is disabled!")
                    raise ValueError(
                        "[SyncTransport:ERROR] :: `{}` pattern is not valid when Multi-Server Mode is enabled. Kindly refer Docs for more Information.".format(
                            pattern
                        )
                    )

            elif key == "multiclient_mode" and isinstance(value, bool):
                if pattern > 0:
                    self.__multiclient_mode = value
                else:
                    self.__multiclient_mode = False
                    logger.critical("Multi-Client Mode is disabled!")
                    raise ValueError(
                        "[SyncTransport:ERROR] :: `{}` pattern is not valid when Multi-Client Mode is enabled. Kindly refer Docs for more Information.".format(
                            pattern
                        )
                    )

            elif key == "bidirectional_mode" and isinstance(value, bool):
                if pattern < 2:
                    self.__bi_mode = value
                else:
                    self.__bi_mode = False
                    logger.warning("Bidirectional data transmission is disabled!")
                    raise ValueError(
                        "[SyncTransport:ERROR] :: `{}` pattern is not valid when Bidirectional Mode is enabled. Kindly refer Docs for more Information!".format(
                            pattern
                        )
                    )

            elif (
                key == "secure_mode"
                and isinstance(value, int)
                and (value in valid_security_mech)
            ):
                self.__secure_mode = value

            elif key == "custom_cert_location" and isinstance(value, str):
                custom_cert_location = os.path.abspath(value)
                assert os.path.isdir(
                    custom_cert_location
                ), "[SyncTransport:ERROR] :: `custom_cert_location` value must be the path to a valid directory!"
                assert check_WriteAccess(
                    custom_cert_location,
                    is_windows=True if os.name == "nt" else False,
                    logging=self.__logging,
                ), "[SyncTransport:ERROR] :: Permission Denied!, cannot write ZMQ authentication certificates to '{}' directory!".format(
                    value
                )
            elif key == "overwrite_cert" and isinstance(value, bool):
                overwrite_cert = value

            elif key == "ssh_tunnel_mode" and isinstance(value, str):
                self.__ssh_tunnel_mode = value.strip()
            elif key == "ssh_tunnel_pwd" and isinstance(value, str):
                self.__ssh_tunnel_pwd = value
            elif key == "ssh_tunnel_keyfile" and isinstance(value, str):
                self.__ssh_tunnel_keyfile = value if os.path.isfile(value) else None
                if self.__ssh_tunnel_keyfile is None:
                    logger.warning(
                        "Discarded invalid or non-existential SSH Tunnel Key-file at {}!".format(
                            value
                        )
                    )

            elif (
                key == "jpeg_compression"
                and not (simplejpeg is None)
                and isinstance(value, (bool, str))
                and not self.__gpu_accelerated
            ):
                if isinstance(value, str) and value.strip().upper() in [
                    "RGB",
                    "BGR",
                    "RGBX",
                    "BGRX",
                    "XBGR",
                    "XRGB",
                    "GRAY",
                    "RGBA",
                    "BGRA",
                    "ABGR",
                    "ARGB",
                    "CMYK",
                ]:
                    self.__jpeg_compression_colorspace = value.strip().upper()
                    self.__jpeg_compression = True
                else:
                    self.__jpeg_compression = value
            elif key == "jpeg_compression_quality" and isinstance(value, (int, float)):
                if value >= 10 and value <= 100:
                    self.__jpeg_compression_quality = int(value)
                else:
                    logger.warning("Skipped invalid `jpeg_compression_quality` value!")
            elif key == "jpeg_compression_fastdct" and isinstance(value, bool):
                self.__jpeg_compression_fastdct = value
            elif key == "jpeg_compression_fastupsample" and isinstance(value, bool):
                self.__jpeg_compression_fastupsample = value

            elif key == "max_retries" and isinstance(value, int) and pattern < 2:
                if value >= 0:
                    self.__max_retries = value
                else:
                    logger.warning("Invalid `max_retries` value skipped!")

            elif key == "request_timeout" and isinstance(value, int) and pattern < 2:
                if value >= 4:
                    self.__request_timeout = value * 1000
                else:
                    logger.warning("Invalid `request_timeout` value skipped!")

            elif (
                key == "subscriber_timeout" and isinstance(value, int) and pattern == 2
            ):
                if value > 0:
                    self.__subscriber_timeout = value * 1000
                else:
                    logger.warning("Invalid `request_timeout` value skipped!")

            elif key == "flag" and isinstance(value, int):
                self.__msg_flag = value
                self.__msg_flag and logger.warning(
                    "The flag optional value is set to `1` (NOBLOCK) for this run. This might cause SyncTransport to not terminate gracefully."
                )
            elif key == "copy" and isinstance(value, bool):
                self.__msg_copy = value
            elif key == "track" and isinstance(value, bool):
                self.__msg_track = value
                self.__msg_copy and self.__msg_track and logger.info(
                    "The `track` optional value will be ignored for this run because `copy=True` is also defined."
                )
            else:
                pass

        if not (self.__ssh_tunnel_mode is None):
            if receive_mode:
                logger.error("SSH Tunneling cannot be enabled for Client-end!")
            else:
                ssh_address = self.__ssh_tunnel_mode
                ssh_address, ssh_port = (
                    ssh_address.split(":")
                    if ":" in ssh_address
                    else [ssh_address, "22"]
                )
                if "47" in ssh_port:
                    self.__ssh_tunnel_mode = self.__ssh_tunnel_mode.replace(
                        ":47", ""
                    )
                else:
                    ssh_user, ssh_ip = (
                        ssh_address.split("@")
                        if "@" in ssh_address
                        else ["", ssh_address]
                    )
                    assert check_open_port(
                        ssh_ip, port=int(ssh_port)
                    ), "[SyncTransport:ERROR] :: Host `{}` is not available for SSH Tunneling at port-{}!".format(
                        ssh_address, ssh_port
                    )

        if self.__multiclient_mode and self.__multiserver_mode:
            raise ValueError(
                "[SyncTransport:ERROR] :: Multi-Client and Multi-Server Mode cannot be enabled simultaneously!"
            )
        elif self.__multiserver_mode or self.__multiclient_mode:
            if self.__bi_mode:
                self.__logging and logger.debug(
                    "Bidirectional Data Transmission is also enabled for this connection!"
                )
            if self.__ssh_tunnel_mode:
                raise ValueError(
                    "[SyncTransport:ERROR] :: SSH Tunneling and {} Mode cannot be enabled simultaneously. Kindly refer docs!".format(
                        "Multi-Server" if self.__multiserver_mode else "Multi-Client"
                    )
                )
        elif self.__bi_mode:
            self.__logging and logger.debug(
                "Bidirectional Data Transmission is enabled for this connection!"
            )
        elif self.__ssh_tunnel_mode:
            self.__logging and logger.debug(
                "SSH Tunneling is enabled for host:`{}` with `{}` back-end.".format(
                    self.__ssh_tunnel_mode,
                    "paramiko" if self.__paramiko_present else "pexpect",
                )
            )

        platform.system() == "Windows" and asyncio.set_event_loop_policy(
            asyncio.WindowsSelectorEventLoopPolicy()
        )

        self.__msg_context = zmq.Context.instance()

        self.__receive_mode = receive_mode

        if self.__secure_mode > 0:
            if receive_mode:
                overwrite_cert = False
                overwrite_cert and logger.warning(
                    "Overwriting ZMQ Authentication certificates is disabled for Client's end!"
                )
            else:
                overwrite_cert and self.__logging and logger.info(
                    "Overwriting ZMQ Authentication certificates over previous ones!"
                )

            try:
                if custom_cert_location:
                    (
                        auth_cert_dir,
                        self.__auth_secretkeys_dir,
                        self.__auth_publickeys_dir,
                    ) = generate_auth_certificates(
                        custom_cert_location, overwrite=overwrite_cert, logging=logging
                    )
                else:
                    (
                        auth_cert_dir,
                        self.__auth_secretkeys_dir,
                        self.__auth_publickeys_dir,
                    ) = generate_auth_certificates(
                        os.path.join(expanduser("~"), ".videoconference4k"),
                        overwrite=overwrite_cert,
                        logging=logging,
                    )
                self.__logging and logger.debug(
                    "`{}` is the default location for storing ZMQ authentication certificates/keys.".format(
                        auth_cert_dir
                    )
                )

                self.__z_auth = ThreadAuthenticator(self.__msg_context)
                self.__z_auth.start()
                self.__z_auth.allow(str(address))

                if self.__secure_mode == 2:
                    self.__z_auth.configure_curve(
                        domain="*", location=self.__auth_publickeys_dir
                    )
                else:
                    self.__z_auth.configure_curve(
                        domain="*", location=auth.CURVE_ALLOW_ANY
                    )
            except zmq.ZMQError as e:
                if "Address in use" in str(e):
                    logger.info("ZMQ Authenticator already running.")
                else:
                    logger.exception(str(e))
                    self.__secure_mode = 0
                    logger.error(
                        "ZMQ Security Mechanism is disabled for this connection due to errors!"
                    )

        if self.__receive_mode:
            address = "*" if address is None else address

            if self.__multiserver_mode:
                if port is None or not isinstance(port, (tuple, list)):
                    raise ValueError(
                        "[SyncTransport:ERROR] :: Incorrect port value! Kindly provide a list/tuple of Server ports while Multi-Server mode is enabled. For more information refer VideoConference4k docs."
                    )
                else:
                    logger.debug(
                        "Enabling Multi-Server Mode at PORTS: {}!".format(port)
                    )
                self.__port_buffer = []
            elif self.__multiclient_mode:
                if port is None:
                    raise ValueError(
                        "[SyncTransport:ERROR] :: Kindly provide a unique & valid port value at Client-end. For more information refer VideoConference4k docs."
                    )
                else:
                    logger.debug(
                        "Enabling Multi-Client Mode at PORT: {} on this device!".format(
                            port
                        )
                    )
                self.__port = port
            else:
                port = "5555" if port is None else port

            try:
                self.__msg_socket = self.__msg_context.socket(msg_pattern[1])

                self.__pattern == 2 and self.__msg_socket.set_hwm(1)

                if self.__secure_mode > 0:
                    server_secret_file = os.path.join(
                        self.__auth_secretkeys_dir, "server.key_secret"
                    )
                    server_public, server_secret = auth.load_certificate(
                        server_secret_file
                    )
                    self.__msg_socket.curve_secretkey = server_secret
                    self.__msg_socket.curve_publickey = server_public
                    self.__msg_socket.curve_server = True

                if self.__pattern == 2:
                    self.__msg_socket.setsockopt_string(zmq.SUBSCRIBE, "")
                    self.__subscriber_timeout and self.__msg_socket.setsockopt(
                        zmq.RCVTIMEO, self.__subscriber_timeout
                    )
                    self.__subscriber_timeout and self.__msg_socket.setsockopt(
                        zmq.LINGER, 0
                    )

                if self.__multiserver_mode:
                    for pt in port:
                        self.__msg_socket.bind(
                            protocol + "://" + str(address) + ":" + str(pt)
                        )
                else:
                    self.__msg_socket.bind(
                        protocol + "://" + str(address) + ":" + str(port)
                    )

                if pattern < 2:
                    if self.__multiserver_mode:
                        self.__connection_address = []
                        for pt in port:
                            self.__connection_address.append(
                                protocol + "://" + str(address) + ":" + str(pt)
                            )
                    else:
                        self.__connection_address = (
                            protocol + "://" + str(address) + ":" + str(port)
                        )
                    self.__msg_pattern = msg_pattern[1]
                    self.__poll.register(self.__msg_socket, zmq.POLLIN)
                    self.__logging and logger.debug(
                        "Reliable transmission is enabled for this pattern with max-retries: {} and timeout: {} secs.".format(
                            self.__max_retries, self.__request_timeout / 1000
                        )
                    )
                else:
                    self.__logging and self.__subscriber_timeout and logger.debug(
                        "Timeout: {} secs is enabled for this system.".format(
                            self.__subscriber_timeout / 1000
                        )
                    )

            except Exception as e:
                logger.exception(str(e))
                self.__secure_mode and logger.critical(
                    "Failed to activate Secure Mode: `{}` for this connection!".format(
                        valid_security_mech[self.__secure_mode]
                    )
                )
                if self.__multiserver_mode or self.__multiclient_mode:
                    raise RuntimeError(
                        "[SyncTransport:ERROR] :: Receive Mode failed to activate {} Mode at address: {} with pattern: {}! Kindly recheck all parameters.".format(
                            (
                                "Multi-Server"
                                if self.__multiserver_mode
                                else "Multi-Client"
                            ),
                            (protocol + "://" + str(address) + ":" + str(port)),
                            pattern,
                        )
                    )
                else:
                    self.__bi_mode and logger.critical(
                        "Failed to activate Bidirectional Mode for this connection!"
                    )
                    raise RuntimeError(
                        "[SyncTransport:ERROR] :: Receive Mode failed to bind address: {} and pattern: {}! Kindly recheck all parameters.".format(
                            (protocol + "://" + str(address) + ":" + str(port)), pattern
                        )
                    )

            self.__logging and logger.debug(
                "Threaded Queue Mode is enabled by default for this connection."
            )

            self.__queue = deque(maxlen=96)

            self.__thread = Thread(target=self.__recv_handler, name="SyncTransport", args=())
            self.__thread.daemon = True
            self.__thread.start()

            if self.__logging:
                logger.debug(
                    "Successfully Binded to address: {} with pattern: {}.".format(
                        (protocol + "://" + str(address) + ":" + str(port)), pattern
                    )
                )
                if self.__gpu_accelerated:
                    logger.debug(
                        "GPU-Accelerated encoding is activated for this connection using NVIDIA hardware."
                    )
                elif self.__jpeg_compression:
                    logger.debug(
                        "JPEG Frame-Compression is activated for this connection with Colorspace:`{}`, Quality:`{}`%, Fastdct:`{}`, and Fastupsample:`{}`.".format(
                            self.__jpeg_compression_colorspace,
                            self.__jpeg_compression_quality,
                            ("enabled" if self.__jpeg_compression_fastdct else "disabled"),
                            (
                                "enabled"
                                if self.__jpeg_compression_fastupsample
                                else "disabled"
                            ),
                        )
                    )
                self.__secure_mode and logger.debug(
                    "Successfully enabled ZMQ Security Mechanism: `{}` for this connection.".format(
                        valid_security_mech[self.__secure_mode]
                    )
                )
                logger.debug("Multi-threaded Receive Mode is successfully enabled.")
                logger.debug("Unique System ID is {}.".format(self.__id))
                logger.debug("Receive Mode is now activated.")

        else:
            address = "localhost" if address is None else address

            if self.__multiserver_mode:
                if port is None:
                    raise ValueError(
                        "[SyncTransport:ERROR] :: Kindly provide a unique & valid port value at Server-end. For more information refer VideoConference4k docs."
                    )
                else:
                    logger.debug(
                        "Enabling Multi-Server Mode at PORT: {} on this device!".format(
                            port
                        )
                    )
                self.__port = port
            elif self.__multiclient_mode:
                if port is None or not isinstance(port, (tuple, list)):
                    raise ValueError(
                        "[SyncTransport:ERROR] :: Incorrect port value! Kindly provide a list/tuple of Client ports while Multi-Client mode is enabled. For more information refer VideoConference4k docs."
                    )
                else:
                    logger.debug(
                        "Enabling Multi-Client Mode at PORTS: {}!".format(port)
                    )
                self.__port_buffer = []
            else:
                port = "5555" if port is None else port

            try:
                self.__msg_socket = self.__msg_context.socket(msg_pattern[0])

                if self.__pattern == 1:
                    self.__msg_socket.REQ_RELAXED = True
                    self.__msg_socket.REQ_CORRELATE = True

                if self.__pattern == 2:
                    self.__msg_socket.set_hwm(1)

                if self.__secure_mode > 0:
                    client_secret_file = os.path.join(
                        self.__auth_secretkeys_dir, "client.key_secret"
                    )
                    client_public, client_secret = auth.load_certificate(
                        client_secret_file
                    )
                    self.__msg_socket.curve_secretkey = client_secret
                    self.__msg_socket.curve_publickey = client_public
                    server_public_file = os.path.join(
                        self.__auth_publickeys_dir, "server.key"
                    )
                    server_public, _ = auth.load_certificate(server_public_file)
                    self.__msg_socket.curve_serverkey = server_public

                if self.__multiclient_mode:
                    for pt in port:
                        self.__msg_socket.connect(
                            protocol + "://" + str(address) + ":" + str(pt)
                        )
                else:
                    if self.__ssh_tunnel_mode:
                        ssh.tunnel_connection(
                            self.__msg_socket,
                            protocol + "://" + str(address) + ":" + str(port),
                            self.__ssh_tunnel_mode,
                            keyfile=self.__ssh_tunnel_keyfile,
                            password=self.__ssh_tunnel_pwd,
                            paramiko=self.__paramiko_present,
                        )
                    else:
                        self.__msg_socket.connect(
                            protocol + "://" + str(address) + ":" + str(port)
                        )

                if pattern < 2:
                    if self.__multiclient_mode:
                        self.__connection_address = []
                        for pt in port:
                            self.__connection_address.append(
                                protocol + "://" + str(address) + ":" + str(pt)
                            )
                    else:
                        self.__connection_address = (
                            protocol + "://" + str(address) + ":" + str(port)
                        )
                    self.__msg_pattern = msg_pattern[0]
                    self.__poll.register(self.__msg_socket, zmq.POLLIN)

                    self.__logging and logger.debug(
                        "Reliable transmission is enabled for this pattern with max-retries: {} and timeout: {} secs.".format(
                            self.__max_retries, self.__request_timeout / 1000
                        )
                    )

            except Exception as e:
                logger.exception(str(e))
                self.__secure_mode and logger.critical(
                    "Failed to activate Secure Mode: `{}` for this connection!".format(
                        valid_security_mech[self.__secure_mode]
                    )
                )
                if self.__multiserver_mode or self.__multiclient_mode:
                    raise RuntimeError(
                        "[SyncTransport:ERROR] :: Send Mode failed to activate {} Mode at address: {} with pattern: {}! Kindly recheck all parameters.".format(
                            (
                                "Multi-Server"
                                if self.__multiserver_mode
                                else "Multi-Client"
                            ),
                            (protocol + "://" + str(address) + ":" + str(port)),
                            pattern,
                        )
                    )
                else:
                    self.__bi_mode and logger.critical(
                        "Failed to activate Bidirectional Mode for this connection!"
                    )
                    self.__ssh_tunnel_mode and logger.critical(
                        "Failed to initiate SSH Tunneling Mode for this server with `{}` back-end!".format(
                            "paramiko" if self.__paramiko_present else "pexpect"
                        )
                    )
                    raise RuntimeError(
                        "[SyncTransport:ERROR] :: Send Mode failed to connect address: {} and pattern: {}! Kindly recheck all parameters.".format(
                            (protocol + "://" + str(address) + ":" + str(port)), pattern
                        )
                    )

            if self.__logging:
                logger.debug(
                    "Successfully connected to address: {} with pattern: {}.".format(
                        (protocol + "://" + str(address) + ":" + str(port)), pattern
                    )
                )
                if self.__gpu_accelerated:
                    logger.debug(
                        "GPU-Accelerated encoding is activated for this connection using NVIDIA hardware."
                    )
                elif self.__jpeg_compression:
                    logger.debug(
                        "JPEG Frame-Compression is activated for this connection with Colorspace:`{}`, Quality:`{}`%, Fastdct:`{}`, and Fastupsample:`{}`.".format(
                            self.__jpeg_compression_colorspace,
                            self.__jpeg_compression_quality,
                            ("enabled" if self.__jpeg_compression_fastdct else "disabled"),
                            (
                                "enabled"
                                if self.__jpeg_compression_fastupsample
                                else "disabled"
                            ),
                        )
                    )
                self.__secure_mode and logger.debug(
                    "Enabled ZMQ Security Mechanism: `{}` for this connection.".format(
                        valid_security_mech[self.__secure_mode]
                    )
                )
                logger.debug("Unique System ID is {}.".format(self.__id))
                logger.debug(
                    "Send Mode is successfully activated and ready to send data."
                )

    def __get_nvidia_encoder(self, width: int, height: int):
        if self.__nvidia_encoder is None:
            from ..utils.nvidia_codec import NvidiaEncoder
            self.__nvidia_encoder = NvidiaEncoder(
                width=width,
                height=height,
                bitrate=self.__gpu_bitrate,
                codec=self.__gpu_codec,
                gpu_id=self.__gpu_id,
                logging=self.__logging,
            )
        return self.__nvidia_encoder

    def __get_nvidia_decoder(self):
        if self.__nvidia_decoder is None:
            from ..utils.nvidia_codec import NvidiaDecoder
            self.__nvidia_decoder = NvidiaDecoder(
                gpu_id=self.__gpu_id,
                logging=self.__logging,
            )
        return self.__nvidia_decoder

    def __recv_handler(self):
        frame = None
        msg_json = None

        while not self.__terminate.is_set():
            if len(self.__queue) >= 96:
                time.sleep(0.000001)
                continue

            if self.__pattern < 2:
                socks = dict(self.__poll.poll(self.__request_timeout * 3))
                if socks.get(self.__msg_socket) == zmq.POLLIN:
                    msg_json = self.__msg_socket.recv_json(
                        flags=self.__msg_flag | zmq.DONTWAIT
                    )
                else:
                    logger.critical("No response from Server(s), Reconnecting again...")
                    self.__msg_socket.close(linger=0)
                    self.__poll.unregister(self.__msg_socket)
                    self.__max_retries -= 1

                    if not (self.__max_retries):
                        if self.__multiserver_mode:
                            logger.error("All Servers seems to be offline, Abandoning!")
                        else:
                            logger.error("Server seems to be offline, Abandoning!")
                        self.__terminate.set()
                        continue

                    try:
                        self.__msg_socket = self.__msg_context.socket(
                            self.__msg_pattern
                        )
                        if isinstance(self.__connection_address, list):
                            for _connection in self.__connection_address:
                                self.__msg_socket.bind(_connection)
                        else:
                            self.__msg_socket.bind(self.__connection_address)
                    except Exception as e:
                        logger.exception(str(e))
                        self.__terminate.set()
                        raise RuntimeError("API failed to restart the Client-end!")
                    self.__poll.register(self.__msg_socket, zmq.POLLIN)

                    continue
            else:
                try:
                    msg_json = self.__msg_socket.recv_json(flags=self.__msg_flag)
                except zmq.ZMQError as e:
                    if e.errno == zmq.EAGAIN:
                        logger.critical("Connection Timeout. Exiting!")
                        self.__terminate.set()
                        self.__queue.append(None)
                        break

            if msg_json and msg_json["terminate_flag"]:
                if self.__multiserver_mode:
                    if msg_json["port"] in self.__port_buffer:
                        if self.__pattern == 1:
                            self.__msg_socket.send_string(
                                "Termination signal successfully received at client!"
                            )
                        self.__port_buffer.remove(msg_json["port"])
                        self.__logging and logger.warning(
                            "Termination signal received from Server at port: {}!".format(
                                msg_json["port"]
                            )
                        )
                    if not self.__port_buffer:
                        logger.critical(
                            "Termination signal received from all Servers!!!"
                        )
                        self.__terminate.set()
                else:
                    if self.__pattern == 1:
                        self.__msg_socket.send_string(
                            "Termination signal successfully received at Client's end!"
                        )
                    self.__terminate.set()
                    self.__logging and logger.critical(
                        "Termination signal received from server!"
                    )
                continue

            try:
                msg_data = self.__msg_socket.recv(
                    flags=self.__msg_flag | zmq.DONTWAIT,
                    copy=self.__msg_copy,
                    track=self.__msg_track,
                )
            except zmq.ZMQError as e:
                logger.critical("Socket Session Expired. Exiting!")
                self.__terminate.set()
                self.__queue.append(None)
                break

            if self.__pattern < 2:
                if self.__bi_mode or self.__multiclient_mode:
                    with self.__return_data_lock:
                        local_return_data = self.__return_data

                    if not (local_return_data is None) and isinstance(
                        local_return_data, np.ndarray
                    ):
                        return_data = np.copy(local_return_data)

                        if not (return_data.flags["C_CONTIGUOUS"]):
                            return_data = np.ascontiguousarray(
                                return_data, dtype=return_data.dtype
                            )

                        if self.__gpu_accelerated:
                            encoder = self.__get_nvidia_encoder(
                                return_data.shape[1], return_data.shape[0]
                            )
                            return_data = encoder.encode(return_data)

                            return_dict = (
                                dict(port=self.__port)
                                if self.__multiclient_mode
                                else dict()
                            )

                            return_dict.update(
                                dict(
                                    return_type=(type(local_return_data).__name__),
                                    compression={
                                        "type": "nvenc",
                                        "codec": self.__gpu_codec,
                                        "width": local_return_data.shape[1],
                                        "height": local_return_data.shape[0],
                                    },
                                    array_dtype="",
                                    array_shape="",
                                    data=None,
                                )
                            )

                            self.__msg_socket.send_json(
                                return_dict, self.__msg_flag | zmq.SNDMORE
                            )
                            self.__msg_socket.send(
                                return_data,
                                flags=self.__msg_flag,
                                copy=self.__msg_copy,
                                track=self.__msg_track,
                            )
                        elif self.__jpeg_compression:
                            if self.__jpeg_compression_colorspace == "GRAY":
                                if return_data.ndim == 2:
                                    return_data = return_data[:, :, np.newaxis]
                                return_data = simplejpeg.encode_jpeg(
                                    return_data,
                                    quality=self.__jpeg_compression_quality,
                                    colorspace=self.__jpeg_compression_colorspace,
                                    fastdct=self.__jpeg_compression_fastdct,
                                )
                            else:
                                return_data = simplejpeg.encode_jpeg(
                                    return_data,
                                    quality=self.__jpeg_compression_quality,
                                    colorspace=self.__jpeg_compression_colorspace,
                                    colorsubsampling="422",
                                    fastdct=self.__jpeg_compression_fastdct,
                                )

                            return_dict = (
                                dict(port=self.__port)
                                if self.__multiclient_mode
                                else dict()
                            )

                            return_dict.update(
                                dict(
                                    return_type=(type(local_return_data).__name__),
                                    compression=(
                                        {
                                            "dct": self.__jpeg_compression_fastdct,
                                            "ups": self.__jpeg_compression_fastupsample,
                                            "colorspace": self.__jpeg_compression_colorspace,
                                        }
                                    ),
                                    array_dtype=(
                                        str(local_return_data.dtype)
                                        if not (self.__jpeg_compression)
                                        else ""
                                    ),
                                    array_shape=(
                                        local_return_data.shape
                                        if not (self.__jpeg_compression)
                                        else ""
                                    ),
                                    data=None,
                                )
                            )

                            self.__msg_socket.send_json(
                                return_dict, self.__msg_flag | zmq.SNDMORE
                            )
                            self.__msg_socket.send(
                                return_data,
                                flags=self.__msg_flag,
                                copy=self.__msg_copy,
                                track=self.__msg_track,
                            )
                        else:
                            return_dict = (
                                dict(port=self.__port)
                                if self.__multiclient_mode
                                else dict()
                            )
                            return_dict.update(
                                dict(
                                    return_type=(type(local_return_data).__name__),
                                    compression=False,
                                    array_dtype=str(local_return_data.dtype),
                                    array_shape=local_return_data.shape,
                                    data=None,
                                )
                            )
                            self.__msg_socket.send_json(
                                return_dict, self.__msg_flag | zmq.SNDMORE
                            )
                            self.__msg_socket.send(
                                return_data,
                                flags=self.__msg_flag,
                                copy=self.__msg_copy,
                                track=self.__msg_track,
                            )
                    else:
                        return_dict = (
                            dict(port=self.__port)
                            if self.__multiclient_mode
                            else dict()
                        )
                        return_dict.update(
                            dict(
                                return_type=(type(local_return_data).__name__),
                                data=local_return_data,
                            )
                        )
                        self.__msg_socket.send_json(return_dict, self.__msg_flag)
                else:
                    self.__msg_socket.send_string(
                        "Data received on device: {} !".format(self.__id)
                    )
            else:
                with self.__return_data_lock:
                    local_return_data = self.__return_data
                if local_return_data:
                    logger.warning("`return_data` is disabled for this pattern!")

            if msg_json.get("compression"):
                compression_info = msg_json["compression"]

                if isinstance(compression_info, dict) and compression_info.get("type") == "nvenc":
                    decoder = self.__get_nvidia_decoder()
                    frame = decoder.decode(
                        bytes(msg_data),
                        width=compression_info.get("width"),
                        height=compression_info.get("height")
                    )
                    if frame is None:
                        self.__terminate.set()
                        raise RuntimeError(
                            "[SyncTransport:ERROR] :: Received NVENC frame decoding failed. "
                            "Width: {}, Height: {}".format(
                                compression_info.get("width"),
                                compression_info.get("height")
                            )
                        )
                else:
                    frame = simplejpeg.decode_jpeg(
                        msg_data,
                        colorspace=compression_info["colorspace"],
                        fastdct=self.__jpeg_compression_fastdct
                        or compression_info["dct"],
                        fastupsample=self.__jpeg_compression_fastupsample
                        or compression_info["ups"],
                    )
                    if frame is None:
                        self.__terminate.set()
                        raise RuntimeError(
                            "[SyncTransport:ERROR] :: Received compressed JPEG frame decoding failed"
                        )
                    if compression_info["colorspace"] == "GRAY" and frame.ndim == 3:
                        frame = np.squeeze(frame, axis=2)
            else:
                frame_buffer = np.frombuffer(msg_data, dtype=msg_json["dtype"])
                frame = frame_buffer.reshape(msg_json["shape"])

            if self.__multiserver_mode:
                if not msg_json["port"] in self.__port_buffer:
                    self.__port_buffer.append(msg_json["port"])
                if msg_json["message"]:
                    self.__queue.append((msg_json["port"], msg_json["message"], frame))
                else:
                    self.__queue.append((msg_json["port"], frame))
            elif self.__bi_mode:
                if msg_json["message"]:
                    self.__queue.append((msg_json["message"], frame))
                else:
                    self.__queue.append((None, frame))
            else:
                self.__queue.append(frame)

    def recv(self, return_data=None) -> Optional[NDArray]:
        if not (self.__receive_mode):
            self.__terminate.set()
            raise ValueError(
                "[SyncTransport:ERROR] :: `recv()` function cannot be used while receive_mode is disabled. Kindly refer VideoConference4k docs!"
            )

        if (self.__bi_mode or self.__multiclient_mode) and not (return_data is None):
            with self.__return_data_lock:
                self.__return_data = return_data

        while not self.__terminate.is_set():
            try:
                if len(self.__queue) > 0:
                    return self.__queue.popleft()
                else:
                    time.sleep(0.00001)
                    continue
            except KeyboardInterrupt:
                self.__terminate.set()
                break
        return None

    def send(self, frame: NDArray, message: Any = None) -> Optional[Any]:
        if self.__receive_mode:
            self.__terminate.set()
            raise ValueError(
                "[SyncTransport:ERROR] :: `send()` function cannot be used while receive_mode is enabled. Kindly refer VideoConference4k docs!"
            )

        if not (message is None) and isinstance(message, np.ndarray):
            logger.warning(
                "Skipped unsupported `message` of datatype: {}!".format(
                    type(message).__name__
                )
            )
            message = None

        exit_flag = True if (frame is None or self.__terminate.is_set()) else False

        if exit_flag:
            msg_dict = dict(port=self.__port) if self.__multiserver_mode else dict()
            msg_dict.update(
                dict(
                    terminate_flag=True,
                    compression=False,
                    message=None,
                    pattern=str(self.__pattern),
                    dtype="",
                    shape="",
                )
            )
            self.__msg_socket.send_json(msg_dict, self.__msg_flag | zmq.SNDMORE)
            self.__msg_socket.send(
                b"",
                flags=self.__msg_flag,
                copy=self.__msg_copy,
                track=self.__msg_track,
            )

            if self.__pattern < 2:
                if self.__bi_mode or self.__multiclient_mode:
                    socks = dict(self.__poll.poll(self.__request_timeout))
                    if socks.get(self.__msg_socket) == zmq.POLLIN:
                        self.__msg_socket.recv_json(flags=self.__msg_flag)
                else:
                    socks = dict(self.__poll.poll(self.__request_timeout))
                    if socks.get(self.__msg_socket) == zmq.POLLIN:
                        self.__msg_socket.recv()
            return None

        if not (frame.flags["C_CONTIGUOUS"]):
            frame = np.ascontiguousarray(frame, dtype=frame.dtype)

        original_shape = frame.shape
        original_dtype = frame.dtype

        if self.__gpu_accelerated:
            encoder = self.__get_nvidia_encoder(frame.shape[1], frame.shape[0])
            encoded_frame = encoder.encode(frame)

            msg_dict = dict(port=self.__port) if self.__multiserver_mode else dict()

            msg_dict.update(
                dict(
                    terminate_flag=False,
                    compression={
                        "type": "nvenc",
                        "codec": self.__gpu_codec,
                        "width": original_shape[1],
                        "height": original_shape[0],
                    },
                    message=message,
                    pattern=str(self.__pattern),
                    dtype="",
                    shape="",
                )
            )

            self.__msg_socket.send_json(msg_dict, self.__msg_flag | zmq.SNDMORE)
            self.__msg_socket.send(
                encoded_frame, flags=self.__msg_flag, copy=self.__msg_copy, track=self.__msg_track
            )

        elif self.__jpeg_compression:
            if self.__jpeg_compression_colorspace == "GRAY":
                if frame.ndim == 2:
                    frame = np.expand_dims(frame, axis=2)
                frame = simplejpeg.encode_jpeg(
                    frame,
                    quality=self.__jpeg_compression_quality,
                    colorspace=self.__jpeg_compression_colorspace,
                    fastdct=self.__jpeg_compression_fastdct,
                )
            else:
                frame = simplejpeg.encode_jpeg(
                    frame,
                    quality=self.__jpeg_compression_quality,
                    colorspace=self.__jpeg_compression_colorspace,
                    colorsubsampling="422",
                    fastdct=self.__jpeg_compression_fastdct,
                )

            msg_dict = dict(port=self.__port) if self.__multiserver_mode else dict()

            msg_dict.update(
                dict(
                    terminate_flag=False,
                    compression=(
                        {
                            "dct": self.__jpeg_compression_fastdct,
                            "ups": self.__jpeg_compression_fastupsample,
                            "colorspace": self.__jpeg_compression_colorspace,
                        }
                    ),
                    message=message,
                    pattern=str(self.__pattern),
                    dtype=str(original_dtype),
                    shape=original_shape,
                )
            )

            self.__msg_socket.send_json(msg_dict, self.__msg_flag | zmq.SNDMORE)
            self.__msg_socket.send(
                frame, flags=self.__msg_flag, copy=self.__msg_copy, track=self.__msg_track
            )

        else:
            msg_dict = dict(port=self.__port) if self.__multiserver_mode else dict()

            msg_dict.update(
                dict(
                    terminate_flag=False,
                    compression=False,
                    message=message,
                    pattern=str(self.__pattern),
                    dtype=str(frame.dtype),
                    shape=frame.shape,
                )
            )

            self.__msg_socket.send_json(msg_dict, self.__msg_flag | zmq.SNDMORE)
            self.__msg_socket.send(
                frame, flags=self.__msg_flag, copy=self.__msg_copy, track=self.__msg_track
            )

        if self.__pattern < 2:
            if self.__bi_mode or self.__multiclient_mode:
                recvd_data = None

                socks = dict(self.__poll.poll(self.__request_timeout))
                if socks.get(self.__msg_socket) == zmq.POLLIN:
                    recv_json = self.__msg_socket.recv_json(flags=self.__msg_flag)
                else:
                    logger.critical("No response from Client, Reconnecting again...")
                    self.__msg_socket.setsockopt(zmq.LINGER, 0)
                    self.__msg_socket.close()
                    self.__poll.unregister(self.__msg_socket)
                    self.__max_retries -= 1

                    if not (self.__max_retries):
                        if self.__multiclient_mode:
                            logger.error(
                                "All Clients failed to respond on multiple attempts."
                            )
                        else:
                            logger.error(
                                "Client failed to respond on multiple attempts."
                            )
                        self.__terminate.set()
                        raise RuntimeError(
                            "[SyncTransport:ERROR] :: Client(s) seems to be offline, Abandoning."
                        )

                    self.__msg_socket = self.__msg_context.socket(self.__msg_pattern)
                    if isinstance(self.__connection_address, list):
                        for _connection in self.__connection_address:
                            self.__msg_socket.connect(_connection)
                    else:
                        if self.__ssh_tunnel_mode:
                            ssh.tunnel_connection(
                                self.__msg_socket,
                                self.__connection_address,
                                self.__ssh_tunnel_mode,
                                keyfile=self.__ssh_tunnel_keyfile,
                                password=self.__ssh_tunnel_pwd,
                                paramiko=self.__paramiko_present,
                            )
                        else:
                            self.__msg_socket.connect(self.__connection_address)
                    self.__poll.register(self.__msg_socket, zmq.POLLIN)
                    return None

                if (
                    self.__multiclient_mode
                    and not recv_json["port"] in self.__port_buffer
                ):
                    self.__port_buffer.append(recv_json["port"])

                if recv_json["return_type"] == "ndarray":
                    recv_array = self.__msg_socket.recv(
                        flags=self.__msg_flag,
                        copy=self.__msg_copy,
                        track=self.__msg_track,
                    )

                    recv_compression = recv_json.get("compression")

                    if isinstance(recv_compression, dict) and recv_compression.get("type") == "nvenc":
                        decoder = self.__get_nvidia_decoder()
                        recvd_data = decoder.decode(
                            bytes(recv_array),
                            width=recv_compression.get("width"),
                            height=recv_compression.get("height")
                        )
                        if recvd_data is None:
                            self.__terminate.set()
                            raise RuntimeError(
                                "[SyncTransport:ERROR] :: Received NVENC frame decoding failed. "
                                "Width: {}, Height: {}".format(
                                    recv_compression.get("width"),
                                    recv_compression.get("height")
                                )
                            )
                    elif recv_compression:
                        recvd_data = simplejpeg.decode_jpeg(
                            recv_array,
                            colorspace=recv_compression["colorspace"],
                            fastdct=self.__jpeg_compression_fastdct
                            or recv_compression["dct"],
                            fastupsample=self.__jpeg_compression_fastupsample
                            or recv_compression["ups"],
                        )
                        if recvd_data is None:
                            self.__terminate.set()
                            raise RuntimeError(
                                "[SyncTransport:ERROR] :: Received compressed frame `{}` decoding failed with flag: {}.".format(
                                    recv_compression,
                                    self.__ex_compression_params,
                                )
                            )

                        if (
                            recv_compression["colorspace"] == "GRAY"
                            and recvd_data.ndim == 3
                        ):
                            recvd_data = np.squeeze(recvd_data, axis=2)
                    else:
                        recvd_data = np.frombuffer(
                            recv_array, dtype=recv_json["array_dtype"]
                        ).reshape(recv_json["array_shape"])
                else:
                    recvd_data = recv_json["data"]

                return (
                    (recv_json["port"], recvd_data)
                    if self.__multiclient_mode
                    else recvd_data
                )
            else:
                socks = dict(self.__poll.poll(self.__request_timeout))
                if socks.get(self.__msg_socket) == zmq.POLLIN:
                    recv_confirmation = self.__msg_socket.recv()
                else:
                    logger.critical("No response from Client, Reconnecting again...")
                    self.__msg_socket.setsockopt(zmq.LINGER, 0)
                    self.__msg_socket.close()
                    self.__poll.unregister(self.__msg_socket)
                    self.__max_retries -= 1

                    if not (self.__max_retries):
                        logger.error("Client failed to respond on repeated attempts.")
                        self.__terminate.set()
                        raise RuntimeError(
                            "[SyncTransport:ERROR] :: Client seems to be offline, Abandoning!"
                        )

                    self.__msg_socket = self.__msg_context.socket(self.__msg_pattern)
                    if self.__ssh_tunnel_mode:
                        ssh.tunnel_connection(
                            self.__msg_socket,
                            self.__connection_address,
                            self.__ssh_tunnel_mode,
                            keyfile=self.__ssh_tunnel_keyfile,
                            password=self.__ssh_tunnel_pwd,
                            paramiko=self.__paramiko_present,
                        )
                    else:
                        self.__msg_socket.connect(self.__connection_address)
                    self.__poll.register(self.__msg_socket, zmq.POLLIN)
                    return None

                self.__logging and logger.debug(recv_confirmation)

    def close(self, kill: bool = False) -> None:
        self.__logging and logger.debug(
            "Terminating various {} Processes.".format(
                "Receive Mode" if self.__receive_mode else "Send Mode"
            )
        )

        if self.__nvidia_encoder is not None:
            self.__nvidia_encoder.close()
            self.__nvidia_encoder = None

        if self.__nvidia_decoder is not None:
            self.__nvidia_decoder.close()
            self.__nvidia_decoder = None

        if self.__receive_mode:
            if not (self.__queue is None) and self.__queue:
                self.__queue.clear()
            self.__terminate.set()
            self.__logging and logger.debug("Terminating. Please wait...")
            if self.__z_auth:
                self.__logging and logger.debug("Terminating Authenticator Thread.")
                self.__z_auth.stop()
                while self.__z_auth.is_alive():
                    pass
            if self.__thread is not None:
                self.__logging and logger.debug("Terminating Main Thread.")
                if self.__thread.is_alive() and kill:
                    logger.warning("Thread still running...Killing it forcefully!")
                    self.__msg_context.destroy()
                    self.__thread.join()
                else:
                    self.__msg_socket.close(linger=0)
                    self.__thread.join()
                self.__thread = None
            self.__logging and logger.debug("Terminated Successfully!")
        else:
            self.__terminate.set()
            kill and logger.warning(
                "`kill` parmeter is only available in the receive mode."
            )
            if self.__z_auth:
                self.__logging and logger.debug("Terminating Authenticator Thread.")
                self.__z_auth.stop()
                while self.__z_auth.is_alive():
                    pass
            if (self.__pattern < 2 and not self.__max_retries) or (
                self.__multiclient_mode and not self.__port_buffer
            ):
                try:
                    self.__msg_socket.setsockopt(zmq.LINGER, 0)
                    self.__msg_socket.close()
                except ZMQError:
                    pass
                finally:
                    return

            if self.__multiserver_mode:
                term_dict = dict(terminate_flag=True, port=self.__port)
            else:
                term_dict = dict(terminate_flag=True)

            try:
                if self.__multiclient_mode:
                    for _ in self.__port_buffer:
                        self.__msg_socket.send_json(term_dict)
                else:
                    self.__msg_socket.send_json(term_dict)

                if self.__pattern < 2:
                    self.__logging and logger.debug("Terminating. Please wait...")
                    if self.__msg_socket.poll(self.__request_timeout // 5, zmq.POLLIN):
                        self.__msg_socket.recv()
            except Exception as e:
                if not isinstance(e, ZMQError):
                    logger.exception(str(e))
            finally:
                self.__msg_socket.setsockopt(zmq.LINGER, 0)
                self.__msg_socket.close()
                self.__logging and logger.debug("Terminated Successfully!")
```

---

## File: pyproject.toml

```text
[build-system]
requires = ["setuptools>=61.0", "wheel"]
build-backend = "setuptools.build_meta"

[project]
name = "videoconference4k"
version = "1.0.0"
description = "Lightweight peer-to-peer video conferencing library for 4K60 streaming"
readme = "README.md"
license = {text = "Apache-2.0"}
requires-python = ">=3.10"
authors = [
    {name = "Blair Chintella", email = "vici0549@gmail.com"}
]
keywords = [
    "OpenCV",
    "video processing",
    "video conferencing",
    "WebRTC",
    "peer-to-peer",
    "P2P",
    "4K video",
    "audio processing",
    "real-time communication",
    "NVIDIA",
    "GPU acceleration",
    "NVENC",
]
classifiers = [
    "Development Status :: 5 - Production/Stable",
    "Operating System :: OS Independent",
    "Operating System :: POSIX",
    "Operating System :: MacOS :: MacOS X",
    "Operating System :: Microsoft :: Windows",
    "Topic :: Multimedia :: Video",
    "Topic :: Multimedia :: Sound/Audio",
    "Topic :: Communications :: Conferencing",
    "Topic :: Scientific/Engineering",
    "Intended Audience :: Developers",
    "License :: OSI Approved :: Apache Software License",
    "Programming Language :: Python :: 3",
    "Programming Language :: Python :: 3.10",
    "Programming Language :: Python :: 3.11",
    "Programming Language :: Python :: 3.12",
    "Programming Language :: Python :: 3.13",
]

dependencies = [
    "numpy",
    "opencv-python>=3.0",
    "colorlog",
    "requests",
    "tqdm",
    "packaging",
    "pyzmq>=4.0",
    "simplejpeg>=1.6.1",
    "msgpack",
    "msgpack-numpy",
    "uvloop; platform_system != 'Windows'",
    "aiortc",
    "sounddevice",
]

[project.optional-dependencies]
gpu = [
    "PyNvVideoCodec>=2.0",
]

[project.urls]
Homepage = "https://github.com/BBC-Esq/Video_Conference_4k"
Repository = "https://github.com/BBC-Esq/Video_Conference_4k"
Issues = "https://github.com/BBC-Esq/Video_Conference_4k/issues"

[tool.setuptools.packages.find]
where = ["."]
include = ["videoconference4k*"]
```

---

## File: rtc/__init__.py

```python
from .connection import RTCConnection
from .tracks import LocalVideoTrack, LocalAudioTrack

__all__ = ["RTCConnection", "LocalVideoTrack", "LocalAudioTrack"]
```

---

## File: rtc/connection.py

```python
import asyncio
import threading
import time
import json
import logging as log
from typing import TypeVar, Optional, Callable, Any, Union
import numpy as np
from numpy.typing import NDArray

from ..utils.common import (
    logger_handler,
    import_dependency_safe,
    log_version,
)
from ..stream.video import VideoStream
from ..capture.audio import AudioCapture
from .tracks import LocalVideoTrack, LocalAudioTrack

aiortc = import_dependency_safe("aiortc", error="silent")
if aiortc is not None:
    from aiortc import (
        RTCPeerConnection,
        RTCSessionDescription,
        RTCIceCandidate,
        RTCConfiguration,
        RTCIceServer,
    )

logger = log.getLogger("RTCConnection")
logger.propagate = False
logger.addHandler(logger_handler())
logger.setLevel(log.DEBUG)

T = TypeVar("T", bound="RTCConnection")

AUDIO_SPECIFIC_OPTIONS = {
    "input_device",
    "output_device",
    "sample_rate",
    "channels",
    "chunk_size",
    "dtype",
    "enable_input",
    "enable_output",
    "latency",
    "blocksize",
}


class RTCConnection:

    def __init__(
        self,
        video_source: Any = None,
        audio_source: Union[AudioCapture, int, None] = None,
        framerate: Union[int, float] = 30,
        sample_rate: int = 48000,
        audio_channels: int = 1,
        enable_video: bool = True,
        enable_audio: bool = True,
        ice_servers: Optional[list] = None,
        logging: bool = False,
        **options: dict
    ):
        self.__logging = logging if isinstance(logging, bool) else False

        log_version(logging=self.__logging)

        import_dependency_safe("aiortc" if aiortc is None else "")

        if aiortc is None:
            raise ImportError("aiortc is required for RTCConnection. Install it with `pip install aiortc`.")

        self.__enable_video = enable_video
        self.__enable_audio = enable_audio
        self.__framerate = framerate
        self.__sample_rate = sample_rate
        self.__audio_channels = audio_channels

        self.__video_source = None
        self.__audio_source = None
        self.__owns_video_source = False
        self.__owns_audio_source = False

        options = {str(k).strip(): v for k, v in options.items()}

        video_options = {k: v for k, v in options.items() if k not in AUDIO_SPECIFIC_OPTIONS}

        if self.__enable_video:
            if video_source is None:
                self.__video_source = VideoStream(source=0, logging=logging, **video_options)
                self.__owns_video_source = True
            elif isinstance(video_source, int):
                self.__video_source = VideoStream(source=video_source, logging=logging, **video_options)
                self.__owns_video_source = True
            elif hasattr(video_source, "read") and callable(video_source.read):
                self.__video_source = video_source
                self.__owns_video_source = False
            else:
                raise ValueError("Invalid video_source. Must be int, None, or object with read() method.")

        if self.__enable_audio:
            if audio_source is None:
                self.__audio_source = AudioCapture(
                    sample_rate=self.__sample_rate,
                    channels=self.__audio_channels,
                    enable_output=False,
                    logging=logging,
                )
                self.__owns_audio_source = True
            elif isinstance(audio_source, int):
                self.__audio_source = AudioCapture(
                    input_device=audio_source,
                    sample_rate=self.__sample_rate,
                    channels=self.__audio_channels,
                    enable_output=False,
                    logging=logging,
                )
                self.__owns_audio_source = True
            elif isinstance(audio_source, AudioCapture):
                self.__audio_source = audio_source
                self.__owns_audio_source = False
            else:
                raise ValueError("Invalid audio_source. Must be int, None, or AudioCapture instance.")

        if ice_servers is None:
            self.__ice_servers = [
                RTCIceServer(urls=["stun:stun.l.google.com:19302"]),
                RTCIceServer(urls=["stun:stun1.l.google.com:19302"]),
            ]
        else:
            self.__ice_servers = []
            for server in ice_servers:
                if isinstance(server, dict):
                    self.__ice_servers.append(RTCIceServer(**server))
                elif isinstance(server, RTCIceServer):
                    self.__ice_servers.append(server)

        self.__pc = None
        self.__local_video_track = None
        self.__local_audio_track = None

        self.__on_video_frame_callback = None
        self.__on_audio_frame_callback = None
        self.__on_connection_state_callback = None
        self.__on_ice_candidate_callback = None

        self.__loop = None
        self.__thread = None
        self.__is_running = False
        self.__terminate = threading.Event()

        self.__pending_ice_candidates = []

        self.__audio_playback = None
        if self.__enable_audio:
            self.__audio_playback = AudioCapture(
                sample_rate=self.__sample_rate,
                channels=self.__audio_channels,
                enable_input=False,
                enable_output=True,
                logging=logging,
            )

        self.__logging and logger.debug("RTCConnection initialized.")

    @property
    def is_running(self) -> bool:
        return self.__is_running

    @property
    def connection_state(self) -> Optional[str]:
        if self.__pc is not None:
            return self.__pc.connectionState
        return None

    @property
    def ice_connection_state(self) -> Optional[str]:
        if self.__pc is not None:
            return self.__pc.iceConnectionState
        return None

    @property
    def ice_gathering_state(self) -> Optional[str]:
        if self.__pc is not None:
            return self.__pc.iceGatheringState
        return None

    def on_video_frame(self, callback: Callable[[NDArray], None]) -> None:
        if callable(callback):
            self.__on_video_frame_callback = callback
            self.__logging and logger.debug("Video frame callback registered.")
        else:
            logger.warning("Invalid callback. Must be callable.")

    def on_audio_frame(self, callback: Callable[[NDArray], None]) -> None:
        if callable(callback):
            self.__on_audio_frame_callback = callback
            self.__logging and logger.debug("Audio frame callback registered.")
        else:
            logger.warning("Invalid callback. Must be callable.")

    def on_connection_state(self, callback: Callable[[str], None]) -> None:
        if callable(callback):
            self.__on_connection_state_callback = callback
            self.__logging and logger.debug("Connection state callback registered.")
        else:
            logger.warning("Invalid callback. Must be callable.")

    def on_ice_candidate(self, callback: Callable[[dict], None]) -> None:
        if callable(callback):
            self.__on_ice_candidate_callback = callback
            self.__logging and logger.debug("ICE candidate callback registered.")
        else:
            logger.warning("Invalid callback. Must be callable.")

    def __ensure_loop(self):
        if self.__loop is None or self.__loop.is_closed():
            self.__loop = asyncio.new_event_loop()
            self.__thread = threading.Thread(target=self.__run_loop, daemon=True)
            self.__thread.start()
            time.sleep(0.1)

    def __run_loop(self):
        asyncio.set_event_loop(self.__loop)
        self.__loop.run_forever()

    def __run_coroutine(self, coro):
        self.__ensure_loop()
        future = asyncio.run_coroutine_threadsafe(coro, self.__loop)
        return future.result(timeout=30)

    async def __create_peer_connection(self):
        config = RTCConfiguration(iceServers=self.__ice_servers)
        self.__pc = RTCPeerConnection(configuration=config)

        @self.__pc.on("connectionstatechange")
        async def on_connectionstatechange():
            self.__logging and logger.debug("Connection state: {}".format(self.__pc.connectionState))
            if self.__on_connection_state_callback is not None:
                try:
                    self.__on_connection_state_callback(self.__pc.connectionState)
                except Exception as e:
                    logger.error("Error in connection state callback: {}".format(e))
            if self.__pc.connectionState == "failed":
                await self.__pc.close()

        @self.__pc.on("iceconnectionstatechange")
        async def on_iceconnectionstatechange():
            self.__logging and logger.debug("ICE connection state: {}".format(self.__pc.iceConnectionState))

        @self.__pc.on("icegatheringstatechange")
        async def on_icegatheringstatechange():
            self.__logging and logger.debug("ICE gathering state: {}".format(self.__pc.iceGatheringState))

        @self.__pc.on("icecandidate")
        async def on_icecandidate(candidate):
            if candidate and self.__on_ice_candidate_callback is not None:
                candidate_dict = {
                    "candidate": candidate.candidate,
                    "sdpMid": candidate.sdpMid,
                    "sdpMLineIndex": candidate.sdpMLineIndex,
                }
                try:
                    self.__on_ice_candidate_callback(candidate_dict)
                except Exception as e:
                    logger.error("Error in ICE candidate callback: {}".format(e))

        @self.__pc.on("track")
        async def on_track(track):
            self.__logging and logger.debug("Received track: {}".format(track.kind))
            if track.kind == "video":
                asyncio.ensure_future(self.__handle_video_track(track))
            elif track.kind == "audio":
                asyncio.ensure_future(self.__handle_audio_track(track))

    async def __handle_video_track(self, track):
        self.__logging and logger.debug("Handling incoming video track.")
        while not self.__terminate.is_set():
            try:
                frame = await asyncio.wait_for(track.recv(), timeout=1.0)
                img = frame.to_ndarray(format="bgr24")
                if self.__on_video_frame_callback is not None:
                    try:
                        self.__on_video_frame_callback(img)
                    except Exception as e:
                        logger.error("Error in video frame callback: {}".format(e))
            except asyncio.TimeoutError:
                continue
            except Exception as e:
                if "MediaStreamError" not in str(type(e)):
                    logger.error("Error receiving video frame: {}".format(e))
                break

    async def __handle_audio_track(self, track):
        self.__logging and logger.debug("Handling incoming audio track.")
        if self.__audio_playback is not None and not self.__audio_playback.is_running:
            self.__audio_playback.start()
        while not self.__terminate.is_set():
            try:
                frame = await asyncio.wait_for(track.recv(), timeout=1.0)
                audio_data = frame.to_ndarray()
                if audio_data.ndim > 1:
                    audio_data = audio_data.T
                if self.__audio_playback is not None:
                    self.__audio_playback.write(audio_data.astype(np.int16))
                if self.__on_audio_frame_callback is not None:
                    try:
                        self.__on_audio_frame_callback(audio_data)
                    except Exception as e:
                        logger.error("Error in audio frame callback: {}".format(e))
            except asyncio.TimeoutError:
                continue
            except Exception as e:
                if "MediaStreamError" not in str(type(e)):
                    logger.error("Error receiving audio frame: {}".format(e))
                break

    async def __add_local_tracks(self):
        if self.__enable_video and self.__video_source is not None:
            if LocalVideoTrack is None:
                raise RuntimeError("aiortc is not properly initialized. LocalVideoTrack is unavailable.")
            self.__local_video_track = LocalVideoTrack(
                video_source=self.__video_source,
                framerate=self.__framerate,
                logging=self.__logging,
            )
            self.__pc.addTrack(self.__local_video_track)
            self.__logging and logger.debug("Added local video track.")

        if self.__enable_audio and self.__audio_source is not None:
            if LocalAudioTrack is None:
                raise RuntimeError("aiortc is not properly initialized. LocalAudioTrack is unavailable.")
            self.__local_audio_track = LocalAudioTrack(
                audio_source=self.__audio_source,
                sample_rate=self.__sample_rate,
                channels=self.__audio_channels,
                logging=self.__logging,
            )
            self.__pc.addTrack(self.__local_audio_track)
            self.__logging and logger.debug("Added local audio track.")

    async def __create_offer_async(self) -> dict:
        await self.__create_peer_connection()
        await self.__add_local_tracks()
        offer = await self.__pc.createOffer()
        await self.__pc.setLocalDescription(offer)

        while self.__pc.iceGatheringState != "complete":
            await asyncio.sleep(0.1)

        return {
            "type": self.__pc.localDescription.type,
            "sdp": self.__pc.localDescription.sdp,
        }

    async def __create_answer_async(self, offer: dict) -> dict:
        await self.__create_peer_connection()
        await self.__add_local_tracks()

        remote_description = RTCSessionDescription(sdp=offer["sdp"], type=offer["type"])
        await self.__pc.setRemoteDescription(remote_description)

        for candidate in self.__pending_ice_candidates:
            await self.__pc.addIceCandidate(candidate)
        self.__pending_ice_candidates.clear()

        answer = await self.__pc.createAnswer()
        await self.__pc.setLocalDescription(answer)

        while self.__pc.iceGatheringState != "complete":
            await asyncio.sleep(0.1)

        return {
            "type": self.__pc.localDescription.type,
            "sdp": self.__pc.localDescription.sdp,
        }

    async def __set_answer_async(self, answer: dict):
        remote_description = RTCSessionDescription(sdp=answer["sdp"], type=answer["type"])
        await self.__pc.setRemoteDescription(remote_description)

        for candidate in self.__pending_ice_candidates:
            await self.__pc.addIceCandidate(candidate)
        self.__pending_ice_candidates.clear()

    async def __add_ice_candidate_async(self, candidate: dict):
        ice_candidate = RTCIceCandidate(
            candidate=candidate.get("candidate"),
            sdpMid=candidate.get("sdpMid"),
            sdpMLineIndex=candidate.get("sdpMLineIndex"),
        )
        if self.__pc is not None and self.__pc.remoteDescription is not None:
            await self.__pc.addIceCandidate(ice_candidate)
        else:
            self.__pending_ice_candidates.append(ice_candidate)

    def create_offer(self) -> dict:
        self.__logging and logger.debug("Creating offer.")
        self.__is_running = True
        return self.__run_coroutine(self.__create_offer_async())

    def create_answer(self, offer: dict) -> dict:
        self.__logging and logger.debug("Creating answer.")
        self.__is_running = True
        return self.__run_coroutine(self.__create_answer_async(offer))

    def set_answer(self, answer: dict) -> None:
        self.__logging and logger.debug("Setting answer.")
        self.__run_coroutine(self.__set_answer_async(answer))

    def add_ice_candidate(self, candidate: dict) -> None:
        self.__logging and logger.debug("Adding ICE candidate.")
        self.__run_coroutine(self.__add_ice_candidate_async(candidate))

    def offer_to_json(self, offer: dict) -> str:
        return json.dumps(offer)

    def json_to_offer(self, json_str: str) -> dict:
        return json.loads(json_str)

    def answer_to_json(self, answer: dict) -> str:
        return json.dumps(answer)

    def json_to_answer(self, json_str: str) -> dict:
        return json.loads(json_str)

    async def __close_async(self):
        if self.__local_video_track is not None:
            self.__local_video_track.stop()
            self.__local_video_track = None

        if self.__local_audio_track is not None:
            self.__local_audio_track.stop()
            self.__local_audio_track = None

        if self.__pc is not None:
            await self.__pc.close()
            self.__pc = None

    def stop(self) -> None:
        self.__logging and logger.debug("Stopping RTCConnection.")
        self.__terminate.set()

        if self.__loop is not None and self.__loop.is_running():
            try:
                future = asyncio.run_coroutine_threadsafe(self.__close_async(), self.__loop)
                future.result(timeout=5)
            except Exception as e:
                logger.error("Error during close: {}".format(e))

        if self.__owns_video_source and self.__video_source is not None:
            if hasattr(self.__video_source, "stop"):
                self.__video_source.stop()
            self.__video_source = None

        if self.__owns_audio_source and self.__audio_source is not None:
            if hasattr(self.__audio_source, "stop"):
                self.__audio_source.stop()
            self.__audio_source = None

        if self.__audio_playback is not None:
            self.__audio_playback.stop()
            self.__audio_playback = None

        if self.__loop is not None and self.__loop.is_running():
            self.__loop.call_soon_threadsafe(self.__loop.stop)

        if self.__thread is not None:
            self.__thread.join(timeout=2)
            self.__thread = None

        self.__loop = None
        self.__is_running = False
        self.__logging and logger.debug("RTCConnection stopped.")
```

---

## File: rtc/tracks.py

```python
import asyncio
import fractions
import time
import numpy as np
from typing import Any, Union

from ..utils.common import import_dependency_safe

aiortc = import_dependency_safe("aiortc", error="silent")
if aiortc is not None:
    from aiortc import VideoStreamTrack, AudioStreamTrack
    from av import VideoFrame, AudioFrame

VIDEO_CLOCK_RATE = 90000
VIDEO_TIME_BASE = fractions.Fraction(1, VIDEO_CLOCK_RATE)
AUDIO_CLOCK_RATE = 48000
AUDIO_TIME_BASE = fractions.Fraction(1, AUDIO_CLOCK_RATE)
AUDIO_PTIME = 0.020

LocalVideoTrack = None
LocalAudioTrack = None

if aiortc is not None:

    class _LocalVideoTrack(VideoStreamTrack):

        kind = "video"

        def __init__(
            self,
            video_source: Any = None,
            framerate: Union[int, float] = 30,
            logging: bool = False,
        ):
            super().__init__()
            self.__logging = logging
            self.__framerate = framerate
            self.__video_ptime = 1 / self.__framerate
            self.__video_source = video_source
            self.__started = False
            self.__timestamp = 0
            self.__start_time = None

        async def recv(self):
            if not self.__started:
                self.__start_time = time.time()
                self.__started = True
                if self.__video_source is not None and hasattr(self.__video_source, "start"):
                    if hasattr(self.__video_source, "is_running"):
                        if not self.__video_source.is_running:
                            self.__video_source.start()
                    else:
                        self.__video_source.start()

            pts = self.__timestamp
            self.__timestamp += int(self.__video_ptime * VIDEO_CLOCK_RATE)

            wait = self.__start_time + (pts / VIDEO_CLOCK_RATE) - time.time()
            if wait > 0:
                await asyncio.sleep(wait)

            frame = None
            if self.__video_source is not None:
                frame = self.__video_source.read()

            if frame is None:
                frame = np.zeros((480, 640, 3), dtype=np.uint8)

            if frame.ndim == 2:
                video_frame = VideoFrame.from_ndarray(frame, format="gray")
            elif frame.ndim == 3 and frame.shape[2] == 4:
                video_frame = VideoFrame.from_ndarray(frame, format="bgra")
            else:
                video_frame = VideoFrame.from_ndarray(frame, format="bgr24")

            video_frame.pts = pts
            video_frame.time_base = VIDEO_TIME_BASE

            return video_frame

        def stop(self):
            super().stop()
            if self.__video_source is not None and hasattr(self.__video_source, "stop"):
                self.__video_source.stop()


    class _LocalAudioTrack(AudioStreamTrack):

        kind = "audio"

        def __init__(
            self,
            audio_source: Any = None,
            sample_rate: int = 48000,
            channels: int = 1,
            logging: bool = False,
        ):
            super().__init__()
            self.__logging = logging
            self.__audio_source = audio_source
            self.__sample_rate = sample_rate
            self.__channels = channels
            self.__samples_per_frame = int(self.__sample_rate * AUDIO_PTIME)
            self.__started = False
            self.__timestamp = 0
            self.__start_time = None

        async def recv(self):
            if not self.__started:
                self.__start_time = time.time()
                self.__started = True
                if self.__audio_source is not None and hasattr(self.__audio_source, "start"):
                    if not self.__audio_source.is_running:
                        self.__audio_source.start()

            pts = self.__timestamp
            self.__timestamp += self.__samples_per_frame

            wait = self.__start_time + (pts / self.__sample_rate) - time.time()
            if wait > 0:
                await asyncio.sleep(wait)

            audio_data = None
            if self.__audio_source is not None:
                audio_data = self.__audio_source.read(timeout=0.001)

            if audio_data is None:
                audio_data = np.zeros((self.__samples_per_frame, self.__channels), dtype=np.int16)

            if audio_data.ndim == 1:
                audio_data = audio_data.reshape(-1, self.__channels)

            if len(audio_data) < self.__samples_per_frame:
                padding = np.zeros((self.__samples_per_frame - len(audio_data), self.__channels), dtype=np.int16)
                audio_data = np.vstack([audio_data, padding])
            elif len(audio_data) > self.__samples_per_frame:
                audio_data = audio_data[:self.__samples_per_frame]

            audio_frame = AudioFrame.from_ndarray(
                audio_data.T if self.__channels > 1 else audio_data.reshape(1, -1),
                format="s16",
                layout="mono" if self.__channels == 1 else "stereo",
            )
            audio_frame.pts = pts
            audio_frame.sample_rate = self.__sample_rate
            audio_frame.time_base = AUDIO_TIME_BASE

            return audio_frame

        def stop(self):
            super().stop()
            if self.__audio_source is not None and hasattr(self.__audio_source, "stop"):
                self.__audio_source.stop()

    LocalVideoTrack = _LocalVideoTrack
    LocalAudioTrack = _LocalAudioTrack
```

---

## File: stream/__init__.py

```python
from .video import VideoStream

__all__ = ["VideoStream"]
```

---

## File: stream/video.py

```python
import cv2
import logging as log
from typing import TypeVar, Tuple, Union, Any
from numpy.typing import NDArray
from ..utils.common import logger_handler, log_version
from ..capture.video import VideoCapture

logger = log.getLogger("VideoStream")
logger.propagate = False
logger.addHandler(logger_handler())
logger.setLevel(log.DEBUG)

T = TypeVar("T", bound="VideoStream")


class VideoStream:
    def __init__(
        self,
        resolution: Tuple[int, int] = (640, 480),
        framerate: Union[int, float] = 30,
        source: Any = 0,
        backend: int = 0,
        time_delay: int = 0,
        colorspace: str = None,
        logging: bool = False,
        **options: dict
    ):
        self.__logging = logging if isinstance(logging, bool) else False
        log_version(logging=self.__logging)
        options = {str(k).strip(): v for k, v in options.items()}
        if "CAP_PROP_FRAME_WIDTH" not in options:
            options["CAP_PROP_FRAME_WIDTH"] = resolution[0]
        if "CAP_PROP_FRAME_HEIGHT" not in options:
            options["CAP_PROP_FRAME_HEIGHT"] = resolution[1]
        if "CAP_PROP_FPS" not in options and framerate > 0:
            options["CAP_PROP_FPS"] = framerate
        self.stream = VideoCapture(
            source=source,
            backend=backend,
            colorspace=colorspace,
            logging=logging,
            time_delay=time_delay,
            **options
        )
        self.framerate = self.stream.framerate

    @property
    def is_running(self) -> bool:
        return self.stream.is_running

    def start(self) -> T:
        self.stream.start()
        return self

    def read(self) -> NDArray:
        return self.stream.read()

    def stop(self) -> None:
        self.stream.stop()
        self.__logging and logger.debug("Terminating VideoStream.")
```

---

## File: utils/__init__.py

```python
from .common import (
    set_cuda_paths,
    logger_handler,
    log_version,
    import_dependency_safe,
    capPropId,
    check_CV_version,
    check_open_port,
    check_WriteAccess,
    check_gstreamer_support,
    generate_auth_certificates,
    validate_auth_keys,
    reducer,
    create_blank_frame,
)

from .nvidia_codec import (
    has_nvidia_codec,
    get_nvidia_info,
    NvidiaEncoder,
    NvidiaDecoder,
    bgr_to_nv12,
    nv12_to_bgr,
)

__all__ = [
    "set_cuda_paths",
    "logger_handler",
    "log_version",
    "import_dependency_safe",
    "capPropId",
    "check_CV_version",
    "check_open_port",
    "check_WriteAccess",
    "check_gstreamer_support",
    "generate_auth_certificates",
    "validate_auth_keys",
    "reducer",
    "create_blank_frame",
    "has_nvidia_codec",
    "get_nvidia_info",
    "NvidiaEncoder",
    "NvidiaDecoder",
    "bgr_to_nv12",
    "nv12_to_bgr",
]
```

---

## File: utils/common.py

```python
import os
import re
import sys
import cv2
import types
import errno
import stat
import shutil
import importlib
import requests
import numpy as np
import logging as log
import platform
import socket
import warnings
from functools import wraps
from tqdm import tqdm
from contextlib import closing
from pathlib import Path
from colorlog import ColoredFormatter
from packaging.version import parse
from requests.adapters import HTTPAdapter, Retry
from ..version import __version__
from typing import List, Optional, Union
from numpy.typing import NDArray


def set_cuda_paths():
    venv_base = Path(sys.executable).parent.parent
    nvidia_base = venv_base / 'Lib' / 'site-packages' / 'nvidia'
    if not nvidia_base.exists():
        return
    paths_to_add = [
        str(nvidia_base / 'cuda_runtime' / 'bin'),
        str(nvidia_base / 'cuda_runtime' / 'lib' / 'x64'),
        str(nvidia_base / 'cuda_runtime' / 'include'),
        str(nvidia_base / 'cublas' / 'bin'),
        str(nvidia_base / 'cudnn' / 'bin'),
        str(nvidia_base / 'cuda_nvrtc' / 'bin'),
        str(nvidia_base / 'cuda_nvcc' / 'bin'),
    ]
    current_path = os.environ.get('PATH', '')
    os.environ['PATH'] = os.pathsep.join(paths_to_add + [current_path])
    triton_cuda_path = nvidia_base / 'cuda_runtime'
    current_cuda = os.environ.get('CUDA_PATH', '')
    os.environ['CUDA_PATH'] = os.pathsep.join([str(triton_cuda_path), current_cuda])


set_cuda_paths()


def logger_handler():
    formatter = ColoredFormatter(
        "{green}{asctime}{reset} :: {bold_purple}{name:^13}{reset} :: {log_color}{levelname:^8}{reset} :: {bold_white}{message}",
        datefmt="%H:%M:%S",
        reset=True,
        log_colors={
            "INFO": "bold_cyan",
            "DEBUG": "bold_yellow",
            "WARNING": "bold_red,fg_thin_yellow",
            "ERROR": "bold_red",
            "CRITICAL": "bold_red,bg_white",
        },
        style="{",
    )
    file_mode = os.environ.get("VC4K_LOGFILE", False)
    handler = log.StreamHandler()
    if file_mode and isinstance(file_mode, str):
        file_path = os.path.abspath(file_mode)
        if (os.name == "nt" or os.access in os.supports_effective_ids) and os.access(
            os.path.dirname(file_path), os.W_OK
        ):
            file_path = (
                os.path.join(file_path, "videoconference4k.log")
                if os.path.isdir(file_path)
                else file_path
            )
            handler = log.FileHandler(file_path, mode="a")
            formatter = log.Formatter(
                "{asctime} :: {name} :: {levelname} :: {message}",
                datefmt="%H:%M:%S",
                style="{",
            )

    handler.setFormatter(formatter)
    return handler


ver_is_logged = False

logger = log.getLogger("Utils")
logger.propagate = False
logger.addHandler(logger_handler())
logger.setLevel(log.DEBUG)


def log_version(logging=False):
    global ver_is_logged
    logging and not (ver_is_logged) and logger.info(
        "Running VideoConference4k Version: {}".format(str(__version__))
    )
    if logging and not (ver_is_logged):
        ver_is_logged = True


def get_module_version(module=None):
    assert not (module is None) and isinstance(
        module, types.ModuleType
    ), "[VideoConference4k:ERROR] :: Invalid module!"

    version = getattr(module, "__version__", None)
    if version is None:
        version = getattr(module, "__VERSION__", None)
    if version is None:
        raise ImportError(
            "[VideoConference4k:ERROR] ::  Can't determine version for module: `{}`!".format(
                module.__name__
            )
        )
    return str(version)


def deprecated(parameter=None, message=None, stacklevel=2):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            if parameter and parameter in kwargs:
                warnings.warn(
                    message
                    or f"Parameter '{parameter}' is deprecated and will be removed in future versions.",
                    DeprecationWarning,
                    stacklevel=stacklevel,
                )
            else:
                warnings.warn(
                    message
                    or f"Function '{func.__name__}' is deprecated and will be removed in future versions.",
                    DeprecationWarning,
                    stacklevel=stacklevel,
                )
            return func(*args, **kwargs)

        return wrapper

    return decorator


def import_dependency_safe(
    name,
    error="raise",
    pkg_name=None,
    min_version=None,
    custom_message=None,
):
    sub_class = ""
    if not name or not isinstance(name, str):
        return None
    else:
        name = name.strip()
        if name.startswith("from"):
            name = name.split(" ")
            name, sub_class = (name[1].strip(), name[-1].strip())

    assert error in [
        "raise",
        "log",
        "silent",
    ], "[VideoConference4k:ERROR] :: Invalid value at `error` parameter."

    install_name = pkg_name if not (pkg_name is None) else name

    msg = (
        custom_message
        if not (custom_message is None)
        else "Failed to find required dependency '{}'. Install it with  `pip install {}` command.".format(
            name, install_name
        )
    )
    try:
        module = importlib.import_module(name)
        module = getattr(module, sub_class) if sub_class else module
    except Exception as e:
        if error == "raise":
            if isinstance(e, ModuleNotFoundError):
                raise ModuleNotFoundError(msg) from None
            else:
                raise ImportError(msg) from e
        elif error == "log":
            logger.error(msg, exc_info=sys.exc_info())
            return None
        else:
            return None

    if not (min_version) is None:
        parent_module = name.split(".")[0]
        if parent_module != name:
            module_to_get = sys.modules[parent_module]
        else:
            module_to_get = module
        version = get_module_version(module_to_get)
        if parse(version) < parse(min_version):
            msg = """Unsupported version '{}' found. VideoConference4k requires '{}' dependency installed with version '{}' or greater. 
            Update it with  `pip install -U {}` command.""".format(
                parent_module, min_version, version, install_name
            )
            if error == "silent":
                return None
            else:
                raise ImportError(msg)

    return module


DEFAULT_TIMEOUT = 3


class TimeoutHTTPAdapter(HTTPAdapter):

    def __init__(self, *args, **kwargs):
        self.timeout = DEFAULT_TIMEOUT
        if "timeout" in kwargs:
            self.timeout = kwargs["timeout"]
            del kwargs["timeout"]
        super().__init__(*args, **kwargs)

    def send(self, request, **kwargs):
        timeout = kwargs.get("timeout")
        if timeout is None:
            kwargs["timeout"] = self.timeout
        return super().send(request, **kwargs)


def check_CV_version() -> int:
    if parse(cv2.__version__) >= parse("4"):
        return 4
    else:
        return 3


def check_open_port(address: str, port: int = 22) -> bool:
    if not address:
        return False
    with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as sock:
        if sock.connect_ex((address, port)) == 0:
            return True
        else:
            return False


def check_WriteAccess(
    path: str, is_windows: bool = False, logging: bool = False
) -> bool:
    dirpath = Path(path)
    try:
        if not (dirpath.exists() and dirpath.is_dir()):
            logger.warning(
                "Specified directory `{}` doesn't exists or valid.".format(path)
            )
            return False
        else:
            path = dirpath.resolve()
    except:
        return False
    if not is_windows:
        uid = os.geteuid()
        gid = os.getegid()
        s = os.stat(path)
        mode = s[stat.ST_MODE]
        return (
            ((s[stat.ST_UID] == uid) and (mode & stat.S_IWUSR))
            or ((s[stat.ST_GID] == gid) and (mode & stat.S_IWGRP))
            or (mode & stat.S_IWOTH)
        )
    else:
        write_accessible = False
        temp_fname = os.path.join(path, "temp.tmp")
        try:
            fd = os.open(temp_fname, os.O_WRONLY | os.O_CREAT | os.O_TRUNC)
            os.close(fd)
            write_accessible = True
        except Exception as e:
            if isinstance(e, PermissionError):
                logger.error(
                    "You don't have adequate access rights to use `{}` directory!".format(
                        path
                    )
                )
            logging and logger.exception(str(e))
        finally:
            delete_file_safe(temp_fname)
        return write_accessible


def check_gstreamer_support(logging: bool = False) -> bool:
    raw = cv2.getBuildInformation()
    gst = [
        x.strip()
        for x in raw.split("\n")
        if x and re.search(r"GStreamer[,-:]+\s*(?:YES|NO)", x)
    ]
    if gst and "YES" in gst[0]:
        version = re.search(r"(\d+\.)?(\d+\.)?(\*|\d+)", gst[0])
        logging and logger.debug("Found GStreamer version:{}".format(version[0]))
        return version[0] >= "1.0.0"
    else:
        logger.warning("GStreamer not found!")
        return False


def check_output(*args: Union[list, tuple], **kwargs: dict) -> bytes:
    import subprocess as sp

    if platform.system() == "Windows":
        sp._cleanup = lambda: None

    retrieve_stderr = kwargs.pop("force_retrieve_stderr", False)

    process = sp.Popen(
        stdout=sp.PIPE,
        stderr=sp.DEVNULL if not (retrieve_stderr) else sp.PIPE,
        *args,
        **kwargs,
    )
    output, stderr = process.communicate()
    retcode = process.poll()

    if retcode and not (retrieve_stderr):
        cmd = kwargs.get("args")
        if cmd is None:
            cmd = args[0]
        error = sp.CalledProcessError(retcode, cmd)
        error.output = output
        raise error

    return output if not (retrieve_stderr) else stderr


def get_supported_vencoders(path: str) -> List[str]:
    encoders = check_output([path, "-hide_banner", "-encoders"])
    splitted = encoders.split(b"\n")
    supported_vencoders = [
        x.decode("utf-8").strip()
        for x in splitted[2 : len(splitted) - 1]
        if x.decode("utf-8").strip().startswith("V")
    ]
    finder = re.compile(r"[A-Z]*[\.]+[A-Z]*\s[a-z0-9_-]*")
    outputs = finder.findall("\n".join(supported_vencoders))
    return [[s for s in o.split(" ")][-1] for o in outputs]


def get_supported_demuxers(path: str) -> List[str]:
    demuxers = check_output([path, "-hide_banner", "-demuxers"])
    splitted = [x.decode("utf-8").strip() for x in demuxers.split(b"\n")]
    split_index = [idx for idx, s in enumerate(splitted) if "--" in s][0]
    supported_demuxers = splitted[split_index + 1 : len(splitted) - 1]
    outputs = [re.search(r"\s[a-z0-9_,-]{2,}\s", d) for d in supported_demuxers]
    outputs = [o.group(0) for o in outputs if o]
    return [o.strip() if not ("," in o) else o.split(",")[-1].strip() for o in outputs]


def get_supported_pixfmts(path: str) -> List[str]:
    pxfmts = check_output([path, "-hide_banner", "-pix_fmts"])
    splitted = pxfmts.split(b"\n")
    srtindex = [i for i, s in enumerate(splitted) if b"-----" in s]
    supported_pxfmts = [
        x.decode("utf-8").strip()
        for x in splitted[srtindex[0] + 1 :]
        if x.decode("utf-8").strip()
    ]
    finder = re.compile(r"([A-Z]*[\.]+[A-Z]*\s[a-z0-9_-]*)(\s+[0-4])(\s+[0-9]+)")
    outputs = finder.findall("\n".join(supported_pxfmts))
    return [[s for s in o[0].split(" ")][-1] for o in outputs if len(o) == 3]


def is_valid_url(path: str, url: str = None, logging: bool = False) -> bool:
    if url is None or not (url):
        logger.warning("URL is empty!")
        return False
    extracted_scheme_url = url.split("://", 1)[0]
    protocols = check_output([path, "-hide_banner", "-protocols"])
    splitted = [x.decode("utf-8").strip() for x in protocols.split(b"\n")]
    supported_protocols = splitted[splitted.index("Output:") + 1 : len(splitted) - 1]
    supported_protocols += (
        ["rtsp", "rtsps"] if "rtsp" in get_supported_demuxers(path) else []
    )
    if extracted_scheme_url and extracted_scheme_url in supported_protocols:
        logging and logger.debug(
            "URL scheme `{}` is supported by FFmpeg.".format(extracted_scheme_url)
        )
        return True
    else:
        logger.warning(
            "URL scheme `{}` isn't supported by FFmpeg!".format(extracted_scheme_url)
        )
        return False


def validate_video(
    path: str, video_path: str = None, logging: bool = False
) -> Optional[dict]:
    if video_path is None or not (video_path):
        logger.warning("Video path is empty!")
        return None

    metadata = check_output(
        [path, "-hide_banner", "-i", video_path], force_retrieve_stderr=True
    )
    stripped_data = [x.decode("utf-8").strip() for x in metadata.split(b"\n")]
    logging and logger.debug(stripped_data)
    result = {}
    for data in stripped_data:
        output_a = re.findall(r"([1-9]\d+)x([1-9]\d+)", data)
        output_b = re.findall(r"\d+(?:\.\d+)?\sfps", data)
        if len(result) == 2:
            break
        if output_b and not "framerate" in result:
            result["framerate"] = re.findall(r"[\d\.\d]+", output_b[0])[0]
        if output_a and not "resolution" in result:
            result["resolution"] = output_a[-1]

    return result if (len(result) == 2) else None


def create_blank_frame(
    frame: NDArray = None, text: str = "", logging: bool = False
) -> NDArray:
    if frame is None or not (isinstance(frame, np.ndarray)):
        raise ValueError("[Utils:ERROR] :: Input frame is invalid!")
    (height, width) = frame.shape[:2]
    blank_frame = np.zeros(frame.shape, frame.dtype)
    if text and isinstance(text, str):
        logging and logger.debug("Adding text: {}".format(text))
        font = cv2.FONT_HERSHEY_SCRIPT_COMPLEX
        fontScale = min(height, width) / (25 / 0.25)
        textsize = cv2.getTextSize(text, font, fontScale, 5)[0]
        textX = (width - textsize[0]) // 2
        textY = (height + textsize[1]) // 2
        cv2.putText(
            blank_frame, text, (textX, textY), font, fontScale, (125, 125, 125), 6
        )

    return blank_frame


def extract_time(value: str) -> int:
    if not (value):
        logger.warning("Value is empty!")
        return 0
    else:
        stripped_data = value.strip()
        t_duration = re.findall(r"\d{2}:\d{2}:\d{2}(?:\.\d{2})?", stripped_data)
        return (
            sum(
                float(x) * 60**i
                for i, x in enumerate(reversed(t_duration[0].split(":")))
            )
            if t_duration
            else 0
        )


def validate_audio(path: str, source: Union[str, list] = None) -> str:
    if source is None or not (source):
        logger.warning("Audio input source is empty!")
        return ""

    cmd = [path, "-hide_banner"] + (
        source if isinstance(source, list) else ["-i", source]
    )
    metadata = check_output(cmd, force_retrieve_stderr=True)
    audio_bitrate_meta = [
        line.strip()
        for line in metadata.decode("utf-8").split("\n")
        if "Audio:" in line
    ]
    audio_bitrate = (
        re.findall(r"([0-9]+)\s(kb|mb|gb)\/s", audio_bitrate_meta[0])[-1]
        if audio_bitrate_meta
        else ""
    )
    audio_samplerate_metadata = [
        line.strip()
        for line in metadata.decode("utf-8").split("\n")
        if all(x in line for x in ["Audio:", "Hz"])
    ]
    audio_samplerate = (
        re.findall(r"[0-9]+\sHz", audio_samplerate_metadata[0])[0]
        if audio_samplerate_metadata
        else ""
    )
    if audio_bitrate:
        return "{}{}".format(int(audio_bitrate[0].strip()), audio_bitrate[1].strip()[0])
    elif audio_samplerate:
        sample_rate_value = int(audio_samplerate.split(" ")[0])
        channels_value = 1 if "mono" in audio_samplerate_metadata[0] else 2
        bit_depth_value = re.findall(
            r"(u|s|f)([0-9]+)(le|be)", audio_samplerate_metadata[0]
        )[0][1]
        return (
            (
                str(
                    get_audio_bitrate(
                        sample_rate_value, channels_value, int(bit_depth_value)
                    )
                )
                + "k"
            )
            if bit_depth_value
            else ""
        )
    else:
        return ""


def get_audio_bitrate(samplerate: int, channels: int, bit_depth: float) -> int:
    return round((samplerate * channels * bit_depth) / 1000)


def get_video_bitrate(width: int, height: int, fps: float, bpp: float) -> int:
    return round((width * height * bpp * fps) / 1000)


def delete_file_safe(file_path: str) -> None:
    try:
        dfile = Path(file_path)
        dfile.unlink(missing_ok=True)
    except Exception as e:
        logger.exception(str(e))


def mkdir_safe(dir_path: str, logging: bool = False) -> None:
    try:
        os.makedirs(dir_path)
        logging and logger.debug("Created directory at `{}`".format(dir_path))
    except (OSError, IOError) as e:
        if e.errno != errno.EACCES and e.errno != errno.EEXIST:
            raise


def delete_ext_safe(
    dir_path: str, extensions: list = [], logging: bool = False
) -> None:
    if not extensions or not os.path.exists(dir_path):
        logger.warning("Invalid input provided for deleting!")
        return

    logger.critical("Clearing Assets at `{}`!".format(dir_path))

    for ext in extensions:
        if len(ext) == 2:
            files_ext = [
                os.path.join(dir_path, f)
                for f in os.listdir(dir_path)
                if f.startswith(ext[0]) and f.endswith(ext[1])
            ]
        else:
            files_ext = [
                os.path.join(dir_path, f)
                for f in os.listdir(dir_path)
                if f.endswith(ext)
            ]
        for file in files_ext:
            delete_file_safe(file)
            logging and logger.debug("Deleted file: `{}`".format(file))


def capPropId(property: str, logging: bool = True) -> int:
    integer_value = 0
    try:
        integer_value = getattr(cv2, property)
    except Exception as e:
        logging and logger.exception(str(e))
        logger.critical("`{}` is not a valid OpenCV property!".format(property))
        return None
    return integer_value


def retrieve_best_interpolation(interpolations: list) -> Optional[int]:
    if isinstance(interpolations, list):
        for intp in interpolations:
            interpolation = capPropId(intp, logging=False)
            if not (interpolation is None):
                return interpolation
    return None


def reducer(
    frame: NDArray = None,
    percentage: Union[int, float] = 0,
    interpolation: int = cv2.INTER_LANCZOS4,
) -> NDArray:
    if frame is None:
        raise ValueError("[Utils:ERROR] :: Input frame cannot be NoneType!")

    if not isinstance(frame, np.ndarray):
        raise ValueError("[Utils:ERROR] :: Input frame must be a numpy array!")

    if not (percentage > 0 and percentage < 90):
        raise ValueError(
            "[Utils:ERROR] :: Given frame-size reduction percentage is invalid, Kindly refer docs."
        )

    if not (isinstance(interpolation, int)):
        raise ValueError(
            "[Utils:ERROR] :: Given interpolation is invalid, Kindly refer docs."
        )

    (height, width) = frame.shape[:2]

    reduction = ((100 - percentage) / 100) * width
    ratio = reduction / float(width)
    dimensions = (int(reduction), int(height * ratio))

    return cv2.resize(frame, dimensions, interpolation=interpolation)


def dict2Args(param_dict: dict) -> list:
    args = []
    for key in param_dict.keys():
        if key in ["-clones"] or key.startswith("-core"):
            if isinstance(param_dict[key], list):
                args.extend(param_dict[key])
            else:
                logger.warning(
                    "{} with invalid datatype:`{}`, Skipped!".format(
                        "Core parameter" if key.startswith("-core") else "Clone",
                        param_dict[key],
                    )
                )
        else:
            args.append(key)
            args.append(str(param_dict[key]))
    return args


def get_valid_ffmpeg_path(
    custom_ffmpeg: str = "",
    is_windows: bool = False,
    ffmpeg_download_path: str = "",
    logging: bool = False,
) -> Union[str, bool]:
    final_path = ""
    if is_windows:
        if custom_ffmpeg:
            final_path += custom_ffmpeg
        else:
            try:
                if not (ffmpeg_download_path):
                    import tempfile

                    ffmpeg_download_path = tempfile.gettempdir()

                logging and logger.debug(
                    "FFmpeg Windows Download Path: {}".format(ffmpeg_download_path)
                )

                os_bit = (
                    ("win64" if platform.machine().endswith("64") else "win32")
                    if is_windows
                    else ""
                )
                _path = download_ffmpeg_binaries(
                    path=ffmpeg_download_path, os_windows=is_windows, os_bit=os_bit
                )
                final_path += _path

            except Exception as e:
                logger.exception(str(e))
                logger.error(
                    "Error in downloading FFmpeg binaries, Check your network and Try again!"
                )
                return False

        if os.path.isfile(final_path):
            pass
        elif os.path.isfile(os.path.join(final_path, "ffmpeg.exe")):
            final_path = os.path.join(final_path, "ffmpeg.exe")
        else:
            logging and logger.debug(
                "No valid FFmpeg executables found at Custom FFmpeg path!"
            )
            return False
    else:
        if custom_ffmpeg:
            if os.path.isfile(custom_ffmpeg):
                final_path += custom_ffmpeg
            elif os.path.isfile(os.path.join(custom_ffmpeg, "ffmpeg")):
                final_path = os.path.join(custom_ffmpeg, "ffmpeg")
            else:
                logging and logger.debug(
                    "No valid FFmpeg executables found at Custom FFmpeg path!"
                )
                return False
        else:
            final_path += "ffmpeg"

    logging and logger.debug("Final FFmpeg Path: {}".format(final_path))

    return final_path if validate_ffmpeg(final_path, logging=logging) else False


def download_ffmpeg_binaries(
    path: str, os_windows: bool = False, os_bit: str = ""
) -> str:
    final_path = ""
    if os_windows and os_bit:
        file_url = "https://github.com/abhiTronix/FFmpeg-Builds/releases/latest/download/ffmpeg-static-{}-gpl.zip".format(
            os_bit
        )

        file_name = os.path.join(
            os.path.abspath(path), "ffmpeg-static-{}-gpl.zip".format(os_bit)
        )
        file_path = os.path.join(
            os.path.abspath(path),
            "ffmpeg-static-{}-gpl/bin/ffmpeg.exe".format(os_bit),
        )
        base_path, _ = os.path.split(file_name)
        if os.path.isfile(file_path):
            final_path += file_path
        else:
            import zipfile

            assert os.access(path, os.W_OK), (
                "[Utils:ERROR] :: Permission Denied, Cannot write binaries to directory = "
                + path
            )
            os.path.isfile(file_name) and delete_file_safe(file_name)
            with open(file_name, "wb") as f:
                logger.debug(
                    "No Custom FFmpeg path provided. Auto-Installing FFmpeg static binaries from GitHub Mirror now. Please wait..."
                )
                with requests.Session() as http:
                    retries = Retry(
                        total=3,
                        backoff_factor=1,
                        status_forcelist=[429, 500, 502, 503, 504],
                    )
                    adapter = TimeoutHTTPAdapter(timeout=2.0, max_retries=retries)
                    http.mount("https://", adapter)
                    response = http.get(file_url, stream=True)
                    response.raise_for_status()
                    total_length = (
                        response.headers.get("content-length")
                        if "content-length" in response.headers
                        else len(response.content)
                    )
                    assert not (
                        total_length is None
                    ), "[Utils:ERROR] :: Failed to retrieve files, check your Internet connectivity!"
                    bar = tqdm(total=int(total_length), unit="B", unit_scale=True)
                    for data in response.iter_content(chunk_size=4096):
                        f.write(data)
                        len(data) > 0 and bar.update(len(data))
                    bar.close()
            logger.debug("Extracting executables.")
            with zipfile.ZipFile(file_name, "r") as zip_ref:
                zip_fname, _ = os.path.split(zip_ref.infolist()[0].filename)
                zip_ref.extractall(base_path)
            delete_file_safe(file_name)
            logger.debug("FFmpeg binaries for Windows configured successfully!")
            final_path += file_path
    return final_path


def validate_ffmpeg(path: str, logging: bool = False) -> bool:
    try:
        version = check_output([path, "-version"])
        firstline = version.split(b"\n")[0]
        version = firstline.split(b" ")[2].strip()
        logging and logger.info("FFmpeg validity Test Passed!")
        logging and logger.debug(
            "Found valid FFmpeg Version: `{}` installed on this system".format(version)
        )
    except Exception as e:
        logging and logger.exception(str(e))
        logger.error("FFmpeg validity Test Failed!")
        return False
    return True


def generate_auth_certificates(
    path: str, overwrite: bool = False, logging: bool = False
) -> tuple:
    import zmq.auth

    if os.path.basename(path) != ".videoconference4k":
        path = os.path.join(path, ".videoconference4k")

    keys_dir = os.path.join(path, "keys")
    mkdir_safe(keys_dir, logging=logging)

    public_keys_dir = os.path.join(keys_dir, "public_keys")
    secret_keys_dir = os.path.join(keys_dir, "private_keys")

    if overwrite:
        for dirs in [public_keys_dir, secret_keys_dir]:
            if os.path.exists(dirs):
                shutil.rmtree(dirs)
            mkdir_safe(dirs, logging=logging)

        server_public_file, server_secret_file = zmq.auth.create_certificates(
            keys_dir, "server"
        )
        client_public_file, client_secret_file = zmq.auth.create_certificates(
            keys_dir, "client"
        )

        for key_file in os.listdir(keys_dir):
            if key_file.endswith(".key"):
                shutil.move(os.path.join(keys_dir, key_file), public_keys_dir)
            elif key_file.endswith(".key_secret"):
                shutil.move(os.path.join(keys_dir, key_file), secret_keys_dir)
            else:
                redundant_key = os.path.join(keys_dir, key_file)
                if os.path.isfile(redundant_key):
                    delete_file_safe(redundant_key)
    else:
        status_public_keys = validate_auth_keys(public_keys_dir, ".key")
        status_private_keys = validate_auth_keys(secret_keys_dir, ".key_secret")

        if status_private_keys and status_public_keys:
            return (keys_dir, secret_keys_dir, public_keys_dir)

        if not (status_public_keys):
            mkdir_safe(public_keys_dir, logging=logging)

        if not (status_private_keys):
            mkdir_safe(secret_keys_dir, logging=logging)

        server_public_file, server_secret_file = zmq.auth.create_certificates(
            keys_dir, "server"
        )
        client_public_file, client_secret_file = zmq.auth.create_certificates(
            keys_dir, "client"
        )

        for key_file in os.listdir(keys_dir):
            if key_file.endswith(".key") and not (status_public_keys):
                shutil.move(
                    os.path.join(keys_dir, key_file), os.path.join(public_keys_dir, ".")
                )
            elif key_file.endswith(".key_secret") and not (status_private_keys):
                shutil.move(
                    os.path.join(keys_dir, key_file), os.path.join(secret_keys_dir, ".")
                )
            else:
                redundant_key = os.path.join(keys_dir, key_file)
                if os.path.isfile(redundant_key):
                    delete_file_safe(redundant_key)

    status_public_keys = validate_auth_keys(public_keys_dir, ".key")
    status_private_keys = validate_auth_keys(secret_keys_dir, ".key_secret")

    if not (status_private_keys) or not (status_public_keys):
        raise RuntimeError(
            "[Utils:ERROR] :: Unable to generate valid ZMQ authentication certificates at `{}`!".format(
                keys_dir
            )
        )

    return (keys_dir, secret_keys_dir, public_keys_dir)


def validate_auth_keys(path: str, extension: str) -> bool:
    if not (os.path.exists(path)):
        return False

    if not (os.listdir(path)):
        return False

    keys_buffer = []

    for key_file in os.listdir(path):
        key = os.path.splitext(key_file)
        if key and (key[0] in ["server", "client"]) and (key[1] == extension):
            keys_buffer.append(key_file)

    len(keys_buffer) == 1 and delete_file_safe(os.path.join(path, keys_buffer[0]))

    return True if (len(keys_buffer) == 2) else False
```

---

## File: utils/nvidia_codec.py

```python
import numpy as np
import logging as log
from typing import Optional, Tuple
from numpy.typing import NDArray

from .common import logger_handler, import_dependency_safe

nvc = import_dependency_safe("PyNvVideoCodec", error="silent")

logger = log.getLogger("NvidiaCodec")
logger.propagate = False
logger.addHandler(logger_handler())
logger.setLevel(log.DEBUG)


def has_nvidia_codec() -> bool:
    if nvc is None:
        return False
    try:
        encoder = nvc.CreateEncoder(64, 64, "NV12", True, codec="h264")
        del encoder
        return True
    except Exception:
        return False


def get_nvidia_info() -> dict:
    info = {
        "available": False,
        "pynvvideocodec_installed": nvc is not None,
        "encoder_functional": False,
    }

    if nvc is None:
        return info

    info["available"] = True

    try:
        encoder = nvc.CreateEncoder(64, 64, "NV12", True, codec="h264")
        del encoder
        info["encoder_functional"] = True
    except Exception as e:
        info["encoder_error"] = str(e)

    return info


def bgr_to_nv12(bgr_frame: NDArray) -> NDArray:
    import cv2

    height, width = bgr_frame.shape[:2]

    yuv_i420 = cv2.cvtColor(bgr_frame, cv2.COLOR_BGR2YUV_I420)

    y = yuv_i420[:height, :]
    u = yuv_i420[height:height + height // 4].reshape(height // 2, width // 2)
    v = yuv_i420[height + height // 4:].reshape(height // 2, width // 2)

    uv = np.empty((height // 2, width), dtype=np.uint8)
    uv[:, 0::2] = u
    uv[:, 1::2] = v

    nv12 = np.vstack([y, uv])
    return nv12.flatten().astype(np.uint8)


def nv12_to_bgr(nv12_data: NDArray, width: int, height: int) -> NDArray:
    import cv2
    nv12_image = nv12_data.reshape((height * 3 // 2, width))
    bgr = cv2.cvtColor(nv12_image, cv2.COLOR_YUV2BGR_NV12)
    return bgr


class NvidiaEncoder:

    def __init__(
        self,
        width: int,
        height: int,
        framerate: int = 30,
        bitrate: int = 8000000,
        codec: str = "h264",
        preset: str = "P1",
        tuning: str = "ultra_low_latency",
        gpu_id: int = 0,
        logging: bool = False,
    ):
        self.__logging = logging
        self.__width = width
        self.__height = height
        self.__framerate = framerate
        self.__codec = codec

        import_dependency_safe("PyNvVideoCodec" if nvc is None else "")

        encoder_params = {
            "preset": preset,
            "tuning_info": tuning,
            "rate_control_mode": "cbr",
            "average_bit_rate": bitrate,
            "max_bit_rate": bitrate,
            "frame_rate": framerate,
            "gop_length": framerate,
        }

        if gpu_id > 0:
            encoder_params["gpu_id"] = gpu_id

        try:
            self.__encoder = nvc.CreateEncoder(
                width,
                height,
                "NV12",
                True,
                codec=codec,
                **encoder_params
            )
        except Exception as e:
            self.__encoder = nvc.CreateEncoder(
                width,
                height,
                "NV12",
                True,
                codec=codec,
            )
            self.__logging and logger.warning(
                "Created encoder with default parameters: {}".format(e)
            )

        self.__logging and logger.debug(
            "NvidiaEncoder initialized: {}x{} @ {}fps, codec={}".format(
                width, height, framerate, codec
            )
        )

    @property
    def width(self) -> int:
        return self.__width

    @property
    def height(self) -> int:
        return self.__height

    @property
    def codec(self) -> str:
        return self.__codec

    def encode(self, bgr_frame: NDArray) -> bytes:
        import cv2

        if bgr_frame.shape[1] != self.__width or bgr_frame.shape[0] != self.__height:
            bgr_frame = cv2.resize(bgr_frame, (self.__width, self.__height))

        nv12_data = bgr_to_nv12(bgr_frame)

        encoded_packets = self.__encoder.Encode(nv12_data)

        if encoded_packets:
            if isinstance(encoded_packets, list):
                return b''.join(bytes(pkt) for pkt in encoded_packets)
            else:
                return bytes(encoded_packets)

        return b''

    def flush(self) -> bytes:
        flushed = self.__encoder.Flush()
        if flushed:
            if isinstance(flushed, list):
                return b''.join(bytes(pkt) for pkt in flushed)
            else:
                return bytes(flushed)
        return b''

    def close(self) -> None:
        self.__logging and logger.debug("Closing NvidiaEncoder")
        try:
            self.flush()
        except Exception:
            pass
        self.__encoder = None


class NvidiaDecoder:

    def __init__(
        self,
        gpu_id: int = 0,
        logging: bool = False,
    ):
        self.__logging = logging
        self.__gpu_id = gpu_id
        self.__decoder = None
        self.__width = None
        self.__height = None

        import_dependency_safe("PyNvVideoCodec" if nvc is None else "")

        self.__logging and logger.debug("NvidiaDecoder initialized")

    @property
    def width(self) -> Optional[int]:
        return self.__width

    @property
    def height(self) -> Optional[int]:
        return self.__height

    def decode(
        self,
        encoded_data: bytes,
        width: Optional[int] = None,
        height: Optional[int] = None
    ) -> Optional[NDArray]:
        if not encoded_data:
            return None

        if width is not None and height is not None:
            self.__width = width
            self.__height = height

        try:
            if self.__decoder is None:
                decoder_params = {}
                if self.__gpu_id > 0:
                    decoder_params["gpu_id"] = self.__gpu_id

                self.__decoder = nvc.CreateDecoder(
                    encoded_stream=encoded_data,
                    **decoder_params
                )
                self.__logging and logger.debug("Decoder created from stream")

            decoded_frames = self.__decoder.Decode(encoded_data)

            if decoded_frames and len(decoded_frames) > 0:
                frame = decoded_frames[-1]

                if hasattr(frame, 'shape'):
                    if len(frame.shape) == 1:
                        if self.__width is None or self.__height is None:
                            raise RuntimeError(
                                "Received 1D NV12 buffer but no dimensions available. "
                                "Ensure width and height are provided."
                            )
                        return nv12_to_bgr(frame, self.__width, self.__height)
                    elif len(frame.shape) == 2:
                        self.__height, self.__width = frame.shape
                        return nv12_to_bgr(frame.flatten(), self.__width, self.__height)
                    elif len(frame.shape) == 3:
                        self.__height, self.__width = frame.shape[:2]
                        return np.array(frame)

                return np.array(frame)

            return None

        except RuntimeError:
            raise
        except Exception as e:
            self.__logging and logger.error("Decode error: {}".format(e))
            return None

    def close(self) -> None:
        self.__logging and logger.debug("Closing NvidiaDecoder")
        self.__decoder = None
```

---

## File: version.py

```python
__version__ = "1.0.0"

```
